// @generated by protoc-gen-es v0.1.1 with parameter "target=ts"
// @generated from file crypto.proto (package penumbra.crypto, syntax proto3)
/* eslint-disable */
/* @ts-nocheck */

import type {BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage} from "@bufbuild/protobuf";
import {Message, proto3, protoInt64} from "@bufbuild/protobuf";

/**
 * Specifies fees paid by a transaction.
 *
 * @generated from message penumbra.crypto.Fee
 */
export class Fee extends Message<Fee> {
  /**
   * The amount of the token used to pay fees.
   *
   * @generated from field: uint64 amount = 1;
   */
  amount = protoInt64.zero;

  /**
   * If present, the asset ID of the token used to pay fees.
   * If absent, specifies the staking token implicitly.
   *
   * @generated from field: penumbra.crypto.AssetId asset_id = 2;
   */
  assetId?: AssetId;

  constructor(data?: PartialMessage<Fee>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "penumbra.crypto.Fee";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "amount", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 2, name: "asset_id", kind: "message", T: AssetId },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Fee {
    return new Fee().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Fee {
    return new Fee().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Fee {
    return new Fee().fromJsonString(jsonString, options);
  }

  static equals(a: Fee | PlainMessage<Fee> | undefined, b: Fee | PlainMessage<Fee> | undefined): boolean {
    return proto3.util.equals(Fee, a, b);
  }
}

/**
 * @generated from message penumbra.crypto.Address
 */
export class Address extends Message<Address> {
  /**
   * @generated from field: bytes inner = 1;
   */
  inner = new Uint8Array(0);

  constructor(data?: PartialMessage<Address>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "penumbra.crypto.Address";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "inner", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Address {
    return new Address().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Address {
    return new Address().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Address {
    return new Address().fromJsonString(jsonString, options);
  }

  static equals(a: Address | PlainMessage<Address> | undefined, b: Address | PlainMessage<Address> | undefined): boolean {
    return proto3.util.equals(Address, a, b);
  }
}

/**
 * @generated from message penumbra.crypto.SpendKey
 */
export class SpendKey extends Message<SpendKey> {
  /**
   * @generated from field: bytes inner = 1;
   */
  inner = new Uint8Array(0);

  constructor(data?: PartialMessage<SpendKey>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "penumbra.crypto.SpendKey";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "inner", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SpendKey {
    return new SpendKey().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SpendKey {
    return new SpendKey().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SpendKey {
    return new SpendKey().fromJsonString(jsonString, options);
  }

  static equals(a: SpendKey | PlainMessage<SpendKey> | undefined, b: SpendKey | PlainMessage<SpendKey> | undefined): boolean {
    return proto3.util.equals(SpendKey, a, b);
  }
}

/**
 * @generated from message penumbra.crypto.SpendVerificationKey
 */
export class SpendVerificationKey extends Message<SpendVerificationKey> {
  /**
   * @generated from field: bytes inner = 1;
   */
  inner = new Uint8Array(0);

  constructor(data?: PartialMessage<SpendVerificationKey>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "penumbra.crypto.SpendVerificationKey";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "inner", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SpendVerificationKey {
    return new SpendVerificationKey().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SpendVerificationKey {
    return new SpendVerificationKey().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SpendVerificationKey {
    return new SpendVerificationKey().fromJsonString(jsonString, options);
  }

  static equals(a: SpendVerificationKey | PlainMessage<SpendVerificationKey> | undefined, b: SpendVerificationKey | PlainMessage<SpendVerificationKey> | undefined): boolean {
    return proto3.util.equals(SpendVerificationKey, a, b);
  }
}

/**
 * @generated from message penumbra.crypto.FullViewingKey
 */
export class FullViewingKey extends Message<FullViewingKey> {
  /**
   * @generated from field: bytes inner = 1;
   */
  inner = new Uint8Array(0);

  constructor(data?: PartialMessage<FullViewingKey>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "penumbra.crypto.FullViewingKey";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "inner", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): FullViewingKey {
    return new FullViewingKey().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): FullViewingKey {
    return new FullViewingKey().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): FullViewingKey {
    return new FullViewingKey().fromJsonString(jsonString, options);
  }

  static equals(a: FullViewingKey | PlainMessage<FullViewingKey> | undefined, b: FullViewingKey | PlainMessage<FullViewingKey> | undefined): boolean {
    return proto3.util.equals(FullViewingKey, a, b);
  }
}

/**
 * @generated from message penumbra.crypto.AccountID
 */
export class AccountID extends Message<AccountID> {
  /**
   * @generated from field: bytes inner = 1;
   */
  inner = new Uint8Array(0);

  constructor(data?: PartialMessage<AccountID>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "penumbra.crypto.AccountID";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "inner", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AccountID {
    return new AccountID().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AccountID {
    return new AccountID().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AccountID {
    return new AccountID().fromJsonString(jsonString, options);
  }

  static equals(a: AccountID | PlainMessage<AccountID> | undefined, b: AccountID | PlainMessage<AccountID> | undefined): boolean {
    return proto3.util.equals(AccountID, a, b);
  }
}

/**
 * @generated from message penumbra.crypto.Diversifier
 */
export class Diversifier extends Message<Diversifier> {
  /**
   * @generated from field: bytes inner = 1;
   */
  inner = new Uint8Array(0);

  constructor(data?: PartialMessage<Diversifier>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "penumbra.crypto.Diversifier";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "inner", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Diversifier {
    return new Diversifier().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Diversifier {
    return new Diversifier().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Diversifier {
    return new Diversifier().fromJsonString(jsonString, options);
  }

  static equals(a: Diversifier | PlainMessage<Diversifier> | undefined, b: Diversifier | PlainMessage<Diversifier> | undefined): boolean {
    return proto3.util.equals(Diversifier, a, b);
  }
}

/**
 * @generated from message penumbra.crypto.AddressIndex
 */
export class AddressIndex extends Message<AddressIndex> {
  /**
   * @generated from field: bytes inner = 1;
   */
  inner = new Uint8Array(0);

  constructor(data?: PartialMessage<AddressIndex>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "penumbra.crypto.AddressIndex";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "inner", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AddressIndex {
    return new AddressIndex().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AddressIndex {
    return new AddressIndex().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AddressIndex {
    return new AddressIndex().fromJsonString(jsonString, options);
  }

  static equals(a: AddressIndex | PlainMessage<AddressIndex> | undefined, b: AddressIndex | PlainMessage<AddressIndex> | undefined): boolean {
    return proto3.util.equals(AddressIndex, a, b);
  }
}

/**
 * @generated from message penumbra.crypto.NoteCommitment
 */
export class NoteCommitment extends Message<NoteCommitment> {
  /**
   * @generated from field: bytes inner = 1;
   */
  inner = new Uint8Array(0);

  constructor(data?: PartialMessage<NoteCommitment>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "penumbra.crypto.NoteCommitment";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "inner", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): NoteCommitment {
    return new NoteCommitment().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): NoteCommitment {
    return new NoteCommitment().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): NoteCommitment {
    return new NoteCommitment().fromJsonString(jsonString, options);
  }

  static equals(a: NoteCommitment | PlainMessage<NoteCommitment> | undefined, b: NoteCommitment | PlainMessage<NoteCommitment> | undefined): boolean {
    return proto3.util.equals(NoteCommitment, a, b);
  }
}

/**
 * @generated from message penumbra.crypto.ValueCommitment
 */
export class ValueCommitment extends Message<ValueCommitment> {
  /**
   * @generated from field: bytes inner = 1;
   */
  inner = new Uint8Array(0);

  constructor(data?: PartialMessage<ValueCommitment>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "penumbra.crypto.ValueCommitment";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "inner", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ValueCommitment {
    return new ValueCommitment().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ValueCommitment {
    return new ValueCommitment().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ValueCommitment {
    return new ValueCommitment().fromJsonString(jsonString, options);
  }

  static equals(a: ValueCommitment | PlainMessage<ValueCommitment> | undefined, b: ValueCommitment | PlainMessage<ValueCommitment> | undefined): boolean {
    return proto3.util.equals(ValueCommitment, a, b);
  }
}

/**
 * @generated from message penumbra.crypto.AssetId
 */
export class AssetId extends Message<AssetId> {
  /**
   * @generated from field: bytes inner = 1;
   */
  inner = new Uint8Array(0);

  constructor(data?: PartialMessage<AssetId>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "penumbra.crypto.AssetId";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "inner", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AssetId {
    return new AssetId().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AssetId {
    return new AssetId().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AssetId {
    return new AssetId().fromJsonString(jsonString, options);
  }

  static equals(a: AssetId | PlainMessage<AssetId> | undefined, b: AssetId | PlainMessage<AssetId> | undefined): boolean {
    return proto3.util.equals(AssetId, a, b);
  }
}

/**
 * @generated from message penumbra.crypto.Denom
 */
export class Denom extends Message<Denom> {
  /**
   * @generated from field: string denom = 1;
   */
  denom = "";

  constructor(data?: PartialMessage<Denom>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "penumbra.crypto.Denom";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "denom", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Denom {
    return new Denom().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Denom {
    return new Denom().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Denom {
    return new Denom().fromJsonString(jsonString, options);
  }

  static equals(a: Denom | PlainMessage<Denom> | undefined, b: Denom | PlainMessage<Denom> | undefined): boolean {
    return proto3.util.equals(Denom, a, b);
  }
}

/**
 * @generated from message penumbra.crypto.Value
 */
export class Value extends Message<Value> {
  /**
   * @generated from field: uint64 amount = 1;
   */
  amount = protoInt64.zero;

  /**
   * @generated from field: penumbra.crypto.AssetId asset_id = 2;
   */
  assetId?: AssetId;

  constructor(data?: PartialMessage<Value>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "penumbra.crypto.Value";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "amount", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 2, name: "asset_id", kind: "message", T: AssetId },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Value {
    return new Value().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Value {
    return new Value().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Value {
    return new Value().fromJsonString(jsonString, options);
  }

  static equals(a: Value | PlainMessage<Value> | undefined, b: Value | PlainMessage<Value> | undefined): boolean {
    return proto3.util.equals(Value, a, b);
  }
}

/**
 * @generated from message penumbra.crypto.MerkleRoot
 */
export class MerkleRoot extends Message<MerkleRoot> {
  /**
   * @generated from field: bytes inner = 1;
   */
  inner = new Uint8Array(0);

  constructor(data?: PartialMessage<MerkleRoot>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "penumbra.crypto.MerkleRoot";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "inner", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MerkleRoot {
    return new MerkleRoot().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MerkleRoot {
    return new MerkleRoot().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MerkleRoot {
    return new MerkleRoot().fromJsonString(jsonString, options);
  }

  static equals(a: MerkleRoot | PlainMessage<MerkleRoot> | undefined, b: MerkleRoot | PlainMessage<MerkleRoot> | undefined): boolean {
    return proto3.util.equals(MerkleRoot, a, b);
  }
}

/**
 * @generated from message penumbra.crypto.Asset
 */
export class Asset extends Message<Asset> {
  /**
   * @generated from field: penumbra.crypto.AssetId id = 1;
   */
  id?: AssetId;

  /**
   * @generated from field: penumbra.crypto.Denom denom = 2;
   */
  denom?: Denom;

  constructor(data?: PartialMessage<Asset>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "penumbra.crypto.Asset";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "id", kind: "message", T: AssetId },
    { no: 2, name: "denom", kind: "message", T: Denom },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Asset {
    return new Asset().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Asset {
    return new Asset().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Asset {
    return new Asset().fromJsonString(jsonString, options);
  }

  static equals(a: Asset | PlainMessage<Asset> | undefined, b: Asset | PlainMessage<Asset> | undefined): boolean {
    return proto3.util.equals(Asset, a, b);
  }
}

/**
 * A validator's identity key (decaf377-rdsa spendauth verification key).
 *
 * @generated from message penumbra.crypto.IdentityKey
 */
export class IdentityKey extends Message<IdentityKey> {
  /**
   * @generated from field: bytes ik = 1;
   */
  ik = new Uint8Array(0);

  constructor(data?: PartialMessage<IdentityKey>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "penumbra.crypto.IdentityKey";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "ik", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): IdentityKey {
    return new IdentityKey().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): IdentityKey {
    return new IdentityKey().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): IdentityKey {
    return new IdentityKey().fromJsonString(jsonString, options);
  }

  static equals(a: IdentityKey | PlainMessage<IdentityKey> | undefined, b: IdentityKey | PlainMessage<IdentityKey> | undefined): boolean {
    return proto3.util.equals(IdentityKey, a, b);
  }
}

/**
 * A validator's governance key (decaf377-rdsa spendauth verification key).
 *
 * @generated from message penumbra.crypto.GovernanceKey
 */
export class GovernanceKey extends Message<GovernanceKey> {
  /**
   * @generated from field: bytes gk = 1;
   */
  gk = new Uint8Array(0);

  constructor(data?: PartialMessage<GovernanceKey>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "penumbra.crypto.GovernanceKey";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "gk", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GovernanceKey {
    return new GovernanceKey().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GovernanceKey {
    return new GovernanceKey().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GovernanceKey {
    return new GovernanceKey().fromJsonString(jsonString, options);
  }

  static equals(a: GovernanceKey | PlainMessage<GovernanceKey> | undefined, b: GovernanceKey | PlainMessage<GovernanceKey> | undefined): boolean {
    return proto3.util.equals(GovernanceKey, a, b);
  }
}

/**
 * @generated from message penumbra.crypto.ConsensusKey
 */
export class ConsensusKey extends Message<ConsensusKey> {
  /**
   * @generated from field: bytes inner = 1;
   */
  inner = new Uint8Array(0);

  constructor(data?: PartialMessage<ConsensusKey>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "penumbra.crypto.ConsensusKey";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "inner", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ConsensusKey {
    return new ConsensusKey().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ConsensusKey {
    return new ConsensusKey().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ConsensusKey {
    return new ConsensusKey().fromJsonString(jsonString, options);
  }

  static equals(a: ConsensusKey | PlainMessage<ConsensusKey> | undefined, b: ConsensusKey | PlainMessage<ConsensusKey> | undefined): boolean {
    return proto3.util.equals(ConsensusKey, a, b);
  }
}

/**
 * @generated from message penumbra.crypto.Note
 */
export class Note extends Message<Note> {
  /**
   * @generated from field: penumbra.crypto.Value value = 1;
   */
  value?: Value;

  /**
   * @generated from field: bytes note_blinding = 2;
   */
  noteBlinding = new Uint8Array(0);

  /**
   * @generated from field: penumbra.crypto.Address address = 3;
   */
  address?: Address;

  constructor(data?: PartialMessage<Note>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "penumbra.crypto.Note";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "value", kind: "message", T: Value },
    { no: 2, name: "note_blinding", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 3, name: "address", kind: "message", T: Address },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Note {
    return new Note().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Note {
    return new Note().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Note {
    return new Note().fromJsonString(jsonString, options);
  }

  static equals(a: Note | PlainMessage<Note> | undefined, b: Note | PlainMessage<Note> | undefined): boolean {
    return proto3.util.equals(Note, a, b);
  }
}

/**
 * @generated from message penumbra.crypto.Nullifier
 */
export class Nullifier extends Message<Nullifier> {
  /**
   * @generated from field: bytes inner = 1;
   */
  inner = new Uint8Array(0);

  constructor(data?: PartialMessage<Nullifier>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "penumbra.crypto.Nullifier";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "inner", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Nullifier {
    return new Nullifier().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Nullifier {
    return new Nullifier().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Nullifier {
    return new Nullifier().fromJsonString(jsonString, options);
  }

  static equals(a: Nullifier | PlainMessage<Nullifier> | undefined, b: Nullifier | PlainMessage<Nullifier> | undefined): boolean {
    return proto3.util.equals(Nullifier, a, b);
  }
}

/**
 * @generated from message penumbra.crypto.SpendAuthSignature
 */
export class SpendAuthSignature extends Message<SpendAuthSignature> {
  /**
   * @generated from field: bytes inner = 1;
   */
  inner = new Uint8Array(0);

  constructor(data?: PartialMessage<SpendAuthSignature>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "penumbra.crypto.SpendAuthSignature";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "inner", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SpendAuthSignature {
    return new SpendAuthSignature().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SpendAuthSignature {
    return new SpendAuthSignature().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SpendAuthSignature {
    return new SpendAuthSignature().fromJsonString(jsonString, options);
  }

  static equals(a: SpendAuthSignature | PlainMessage<SpendAuthSignature> | undefined, b: SpendAuthSignature | PlainMessage<SpendAuthSignature> | undefined): boolean {
    return proto3.util.equals(SpendAuthSignature, a, b);
  }
}

/**
 * @generated from message penumbra.crypto.BindingSignature
 */
export class BindingSignature extends Message<BindingSignature> {
  /**
   * @generated from field: bytes inner = 1;
   */
  inner = new Uint8Array(0);

  constructor(data?: PartialMessage<BindingSignature>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "penumbra.crypto.BindingSignature";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "inner", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): BindingSignature {
    return new BindingSignature().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): BindingSignature {
    return new BindingSignature().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): BindingSignature {
    return new BindingSignature().fromJsonString(jsonString, options);
  }

  static equals(a: BindingSignature | PlainMessage<BindingSignature> | undefined, b: BindingSignature | PlainMessage<BindingSignature> | undefined): boolean {
    return proto3.util.equals(BindingSignature, a, b);
  }
}

/**
 * The body of an output description, including only the minimal
 * data required to scan and process the output.
 *
 * @generated from message penumbra.crypto.NotePayload
 */
export class NotePayload extends Message<NotePayload> {
  /**
   * The note commitment for the output note. 32 bytes.
   *
   * @generated from field: penumbra.crypto.NoteCommitment note_commitment = 1;
   */
  noteCommitment?: NoteCommitment;

  /**
   * The encoding of an ephemeral public key. 32 bytes.
   *
   * @generated from field: bytes ephemeral_key = 2;
   */
  ephemeralKey = new Uint8Array(0);

  /**
   * An encryption of the newly created note.
   * 132 = 1(type) + 11(d) + 8(amount) + 32(asset_id) + 32(rcm) + 32(pk_d) + 16(MAC) bytes.
   *
   * @generated from field: bytes encrypted_note = 3;
   */
  encryptedNote = new Uint8Array(0);

  constructor(data?: PartialMessage<NotePayload>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "penumbra.crypto.NotePayload";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "note_commitment", kind: "message", T: NoteCommitment },
    { no: 2, name: "ephemeral_key", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 3, name: "encrypted_note", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): NotePayload {
    return new NotePayload().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): NotePayload {
    return new NotePayload().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): NotePayload {
    return new NotePayload().fromJsonString(jsonString, options);
  }

  static equals(a: NotePayload | PlainMessage<NotePayload> | undefined, b: NotePayload | PlainMessage<NotePayload> | undefined): boolean {
    return proto3.util.equals(NotePayload, a, b);
  }
}

/**
 * An authentication path from a note commitment to the root of the note commitment tree.
 *
 * @generated from message penumbra.crypto.NoteCommitmentProof
 */
export class NoteCommitmentProof extends Message<NoteCommitmentProof> {
  /**
   * @generated from field: penumbra.crypto.NoteCommitment note_commitment = 1;
   */
  noteCommitment?: NoteCommitment;

  /**
   * @generated from field: uint64 position = 2;
   */
  position = protoInt64.zero;

  /**
   * always length 24
   *
   * @generated from field: repeated penumbra.crypto.MerklePathChunk auth_path = 3;
   */
  authPath: MerklePathChunk[] = [];

  constructor(data?: PartialMessage<NoteCommitmentProof>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "penumbra.crypto.NoteCommitmentProof";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "note_commitment", kind: "message", T: NoteCommitment },
    { no: 2, name: "position", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 3, name: "auth_path", kind: "message", T: MerklePathChunk, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): NoteCommitmentProof {
    return new NoteCommitmentProof().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): NoteCommitmentProof {
    return new NoteCommitmentProof().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): NoteCommitmentProof {
    return new NoteCommitmentProof().fromJsonString(jsonString, options);
  }

  static equals(a: NoteCommitmentProof | PlainMessage<NoteCommitmentProof> | undefined, b: NoteCommitmentProof | PlainMessage<NoteCommitmentProof> | undefined): boolean {
    return proto3.util.equals(NoteCommitmentProof, a, b);
  }
}

/**
 * A set of 3 sibling hashes in the auth path for some note commitment.
 *
 * @generated from message penumbra.crypto.MerklePathChunk
 */
export class MerklePathChunk extends Message<MerklePathChunk> {
  /**
   * @generated from field: bytes sibling_1 = 1;
   */
  sibling1 = new Uint8Array(0);

  /**
   * @generated from field: bytes sibling_2 = 2;
   */
  sibling2 = new Uint8Array(0);

  /**
   * @generated from field: bytes sibling_3 = 3;
   */
  sibling3 = new Uint8Array(0);

  constructor(data?: PartialMessage<MerklePathChunk>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "penumbra.crypto.MerklePathChunk";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "sibling_1", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 2, name: "sibling_2", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 3, name: "sibling_3", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MerklePathChunk {
    return new MerklePathChunk().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MerklePathChunk {
    return new MerklePathChunk().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MerklePathChunk {
    return new MerklePathChunk().fromJsonString(jsonString, options);
  }

  static equals(a: MerklePathChunk | PlainMessage<MerklePathChunk> | undefined, b: MerklePathChunk | PlainMessage<MerklePathChunk> | undefined): boolean {
    return proto3.util.equals(MerklePathChunk, a, b);
  }
}

/**
 * A clue for use with Fuzzy Message Detection.
 *
 * @generated from message penumbra.crypto.Clue
 */
export class Clue extends Message<Clue> {
  /**
   * @generated from field: bytes inner = 1;
   */
  inner = new Uint8Array(0);

  constructor(data?: PartialMessage<Clue>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "penumbra.crypto.Clue";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "inner", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Clue {
    return new Clue().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Clue {
    return new Clue().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Clue {
    return new Clue().fromJsonString(jsonString, options);
  }

  static equals(a: Clue | PlainMessage<Clue> | undefined, b: Clue | PlainMessage<Clue> | undefined): boolean {
    return proto3.util.equals(Clue, a, b);
  }
}

