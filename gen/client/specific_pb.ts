// @generated by protoc-gen-es v0.1.1 with parameter "target=ts"
// @generated from file client/specific.proto (package penumbra.client.specific, syntax proto3)
/* eslint-disable */
/* @ts-nocheck */

import type {BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage} from "@bufbuild/protobuf";
import {Message, proto3, protoInt64} from "@bufbuild/protobuf";
import {TradingPair} from "../dex_pb.js";
import {IdentityKey} from "../crypto_pb.js";
import {CommitmentProof} from "../proofs_pb.js";

/**
 * Requests batch swap data associated with a given height and trading pair from the view service.
 *
 * @generated from message penumbra.client.specific.BatchSwapOutputDataRequest
 */
export class BatchSwapOutputDataRequest extends Message<BatchSwapOutputDataRequest> {
  /**
   * @generated from field: uint64 height = 1;
   */
  height = protoInt64.zero;

  /**
   * @generated from field: penumbra.dex.TradingPair trading_pair = 2;
   */
  tradingPair?: TradingPair;

  constructor(data?: PartialMessage<BatchSwapOutputDataRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "penumbra.client.specific.BatchSwapOutputDataRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "height", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 2, name: "trading_pair", kind: "message", T: TradingPair },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): BatchSwapOutputDataRequest {
    return new BatchSwapOutputDataRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): BatchSwapOutputDataRequest {
    return new BatchSwapOutputDataRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): BatchSwapOutputDataRequest {
    return new BatchSwapOutputDataRequest().fromJsonString(jsonString, options);
  }

  static equals(a: BatchSwapOutputDataRequest | PlainMessage<BatchSwapOutputDataRequest> | undefined, b: BatchSwapOutputDataRequest | PlainMessage<BatchSwapOutputDataRequest> | undefined): boolean {
    return proto3.util.equals(BatchSwapOutputDataRequest, a, b);
  }
}

/**
 * Requests CPMM reserves data associated with a given trading pair from the view service.
 *
 * @generated from message penumbra.client.specific.StubCPMMReservesRequest
 */
export class StubCPMMReservesRequest extends Message<StubCPMMReservesRequest> {
  /**
   * @generated from field: penumbra.dex.TradingPair trading_pair = 1;
   */
  tradingPair?: TradingPair;

  constructor(data?: PartialMessage<StubCPMMReservesRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "penumbra.client.specific.StubCPMMReservesRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "trading_pair", kind: "message", T: TradingPair },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): StubCPMMReservesRequest {
    return new StubCPMMReservesRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): StubCPMMReservesRequest {
    return new StubCPMMReservesRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): StubCPMMReservesRequest {
    return new StubCPMMReservesRequest().fromJsonString(jsonString, options);
  }

  static equals(a: StubCPMMReservesRequest | PlainMessage<StubCPMMReservesRequest> | undefined, b: StubCPMMReservesRequest | PlainMessage<StubCPMMReservesRequest> | undefined): boolean {
    return proto3.util.equals(StubCPMMReservesRequest, a, b);
  }
}

/**
 * @generated from message penumbra.client.specific.ValidatorStatusRequest
 */
export class ValidatorStatusRequest extends Message<ValidatorStatusRequest> {
  /**
   * The expected chain id (empty string if no expectation).
   *
   * @generated from field: string chain_id = 1;
   */
  chainId = "";

  /**
   * @generated from field: penumbra.crypto.IdentityKey identity_key = 2;
   */
  identityKey?: IdentityKey;

  constructor(data?: PartialMessage<ValidatorStatusRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "penumbra.client.specific.ValidatorStatusRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "chain_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "identity_key", kind: "message", T: IdentityKey },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ValidatorStatusRequest {
    return new ValidatorStatusRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ValidatorStatusRequest {
    return new ValidatorStatusRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ValidatorStatusRequest {
    return new ValidatorStatusRequest().fromJsonString(jsonString, options);
  }

  static equals(a: ValidatorStatusRequest | PlainMessage<ValidatorStatusRequest> | undefined, b: ValidatorStatusRequest | PlainMessage<ValidatorStatusRequest> | undefined): boolean {
    return proto3.util.equals(ValidatorStatusRequest, a, b);
  }
}

/**
 * Performs a key-value query, either by key or by key hash.
 *
 * Proofs are only supported by key.
 *
 * @generated from message penumbra.client.specific.KeyValueRequest
 */
export class KeyValueRequest extends Message<KeyValueRequest> {
  /**
   * The expected chain id (empty string if no expectation).
   *
   * @generated from field: string chain_id = 1;
   */
  chainId = "";

  /**
   * If set, the key to fetch from storage.
   *
   * @generated from field: bytes key = 2;
   */
  key = new Uint8Array(0);

  /**
   * whether to return a proof
   *
   * @generated from field: bool proof = 3;
   */
  proof = false;

  constructor(data?: PartialMessage<KeyValueRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "penumbra.client.specific.KeyValueRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "chain_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "key", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 3, name: "proof", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): KeyValueRequest {
    return new KeyValueRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): KeyValueRequest {
    return new KeyValueRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): KeyValueRequest {
    return new KeyValueRequest().fromJsonString(jsonString, options);
  }

  static equals(a: KeyValueRequest | PlainMessage<KeyValueRequest> | undefined, b: KeyValueRequest | PlainMessage<KeyValueRequest> | undefined): boolean {
    return proto3.util.equals(KeyValueRequest, a, b);
  }
}

/**
 * @generated from message penumbra.client.specific.KeyValueResponse
 */
export class KeyValueResponse extends Message<KeyValueResponse> {
  /**
   * @generated from field: bytes value = 1;
   */
  value = new Uint8Array(0);

  /**
   * @generated from field: ics23.CommitmentProof proof = 2;
   */
  proof?: CommitmentProof;

  constructor(data?: PartialMessage<KeyValueResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "penumbra.client.specific.KeyValueResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "value", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 2, name: "proof", kind: "message", T: CommitmentProof },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): KeyValueResponse {
    return new KeyValueResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): KeyValueResponse {
    return new KeyValueResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): KeyValueResponse {
    return new KeyValueResponse().fromJsonString(jsonString, options);
  }

  static equals(a: KeyValueResponse | PlainMessage<KeyValueResponse> | undefined, b: KeyValueResponse | PlainMessage<KeyValueResponse> | undefined): boolean {
    return proto3.util.equals(KeyValueResponse, a, b);
  }
}

