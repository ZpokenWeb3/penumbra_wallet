// @generated by protoc-gen-connect-web v0.2.1 with parameter "target=ts"
// @generated from file view.proto (package penumbra.view, syntax proto3)
/* eslint-disable */
/* @ts-nocheck */

import {AssetRequest, ChainParamsRequest, FMDParametersRequest, NoteByCommitmentRequest, NotesRequest, NullifierStatusRequest, NullifierStatusResponse, QuarantinedNoteRecord, QuarantinedNotesRequest, SpendableNoteRecord, StatusRequest, StatusResponse, StatusStreamRequest, StatusStreamResponse, TransactionHashStreamResponse, TransactionsRequest, TransactionStreamResponse, WitnessRequest} from "./view_pb.js";
import {MethodKind} from "@bufbuild/protobuf";
import {WitnessData} from "./transaction_pb.js";
import {Asset} from "./crypto_pb.js";
import {ChainParameters, FmdParameters} from "./chain_pb.js";

/**
 * The view protocol is used by a view client, who wants to do some
 * transaction-related actions, to request data from a view service, which is
 * responsible for synchronizing and scanning the public chain state with one or
 * more full viewing keys.
 *
 * View protocol requests include a hash of the full viewing key, used to
 * identify which set of data to query.  This also works as a pseudo-auth system
 * (assuming transport security, the client has to know the FVK to request its
 * data).  (TODO: refine this)
 *
 * @generated from service penumbra.view.ViewProtocol
 */
export const ViewProtocol = {
  typeName: "penumbra.view.ViewProtocol",
  methods: {
    /**
     * Get current status of chain sync
     *
     * @generated from rpc penumbra.view.ViewProtocol.Status
     */
    status: {
      name: "Status",
      I: StatusRequest,
      O: StatusResponse,
      kind: MethodKind.Unary,
    },
    /**
     * Stream sync status updates until the view service has caught up with the chain.
     *
     * @generated from rpc penumbra.view.ViewProtocol.StatusStream
     */
    statusStream: {
      name: "StatusStream",
      I: StatusStreamRequest,
      O: StatusStreamResponse,
      kind: MethodKind.ServerStreaming,
    },
    /**
     * Queries for notes that have been accepted by the chain.
     *
     * @generated from rpc penumbra.view.ViewProtocol.Notes
     */
    notes: {
      name: "Notes",
      I: NotesRequest,
      O: SpendableNoteRecord,
      kind: MethodKind.ServerStreaming,
    },
    /**
     * Queries for notes that have been quarantined until the end of an unbonding period.
     *
     * @generated from rpc penumbra.view.ViewProtocol.QuarantinedNotes
     */
    quarantinedNotes: {
      name: "QuarantinedNotes",
      I: QuarantinedNotesRequest,
      O: QuarantinedNoteRecord,
      kind: MethodKind.ServerStreaming,
    },
    /**
     * Returns authentication paths for the given note commitments.
     *
     * This method takes a batch of input commitments, rather than just one, so
     * that the client can get a consistent set of authentication paths to a
     * common root.  (Otherwise, if a client made multiple requests, the wallet
     * service could have advanced the note commitment tree state between queries).
     *
     * @generated from rpc penumbra.view.ViewProtocol.Witness
     */
    witness: {
      name: "Witness",
      I: WitnessRequest,
      O: WitnessData,
      kind: MethodKind.Unary,
    },
    /**
     * Queries for assets.
     *
     * @generated from rpc penumbra.view.ViewProtocol.Assets
     */
    assets: {
      name: "Assets",
      I: AssetRequest,
      O: Asset,
      kind: MethodKind.ServerStreaming,
    },
    /**
     * Query for the current chain parameters.
     *
     * @generated from rpc penumbra.view.ViewProtocol.ChainParameters
     */
    chainParameters: {
      name: "ChainParameters",
      I: ChainParamsRequest,
      O: ChainParameters,
      kind: MethodKind.Unary,
    },
    /**
     * Query for the current FMD parameters.
     *
     * @generated from rpc penumbra.view.ViewProtocol.FMDParameters
     */
    fMDParameters: {
      name: "FMDParameters",
      I: FMDParametersRequest,
      O: FmdParameters,
      kind: MethodKind.Unary,
    },
    /**
     * Query for a note by its note commitment, optionally waiting until the note is detected.
     *
     * @generated from rpc penumbra.view.ViewProtocol.NoteByCommitment
     */
    noteByCommitment: {
      name: "NoteByCommitment",
      I: NoteByCommitmentRequest,
      O: SpendableNoteRecord,
      kind: MethodKind.Unary,
    },
    /**
     * Query for whether a nullifier has been spent, optionally waiting until it is spent.
     *
     * @generated from rpc penumbra.view.ViewProtocol.NullifierStatus
     */
    nullifierStatus: {
      name: "NullifierStatus",
      I: NullifierStatusRequest,
      O: NullifierStatusResponse,
      kind: MethodKind.Unary,
    },
    /**
     * Query for the transaction hashes in the given range of blocks.
     *
     * @generated from rpc penumbra.view.ViewProtocol.TransactionHashes
     */
    transactionHashes: {
      name: "TransactionHashes",
      I: TransactionsRequest,
      O: TransactionHashStreamResponse,
      kind: MethodKind.ServerStreaming,
    },
    /**
     * Query for the full transactions in the given range of blocks.
     *
     * @generated from rpc penumbra.view.ViewProtocol.Transactions
     */
    transactions: {
      name: "Transactions",
      I: TransactionsRequest,
      O: TransactionStreamResponse,
      kind: MethodKind.ServerStreaming,
    },
  }
} as const;

