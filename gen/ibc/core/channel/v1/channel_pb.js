// @generated by protoc-gen-es v0.1.1 with parameter "target=js"
// @generated from file ibc/core/channel/v1/channel.proto (package ibc.core.channel.v1, syntax proto3)
/* eslint-disable */
/* @ts-nocheck */

import {proto3} from "@bufbuild/protobuf";
import {Height} from "../../client/v1/client_pb.js";

/**
 * State defines if a channel is in one of the following states:
 * CLOSED, INIT, TRYOPEN, OPEN or UNINITIALIZED.
 *
 * @generated from enum ibc.core.channel.v1.State
 */
export const State = proto3.makeEnum(
  "ibc.core.channel.v1.State",
  [
    {no: 0, name: "STATE_UNINITIALIZED_UNSPECIFIED", localName: "UNINITIALIZED_UNSPECIFIED"},
    {no: 1, name: "STATE_INIT", localName: "INIT"},
    {no: 2, name: "STATE_TRYOPEN", localName: "TRYOPEN"},
    {no: 3, name: "STATE_OPEN", localName: "OPEN"},
    {no: 4, name: "STATE_CLOSED", localName: "CLOSED"},
  ],
);

/**
 * Order defines if a channel is ORDERED or UNORDERED
 *
 * @generated from enum ibc.core.channel.v1.Order
 */
export const Order = proto3.makeEnum(
  "ibc.core.channel.v1.Order",
  [
    {no: 0, name: "ORDER_NONE_UNSPECIFIED", localName: "NONE_UNSPECIFIED"},
    {no: 1, name: "ORDER_UNORDERED", localName: "UNORDERED"},
    {no: 2, name: "ORDER_ORDERED", localName: "ORDERED"},
  ],
);

/**
 * Channel defines pipeline for exactly-once packet delivery between specific
 * modules on separate blockchains, which has at least one end capable of
 * sending packets and one end capable of receiving packets.
 *
 * @generated from message ibc.core.channel.v1.Channel
 */
export const Channel = proto3.makeMessageType(
  "ibc.core.channel.v1.Channel",
  () => [
    { no: 1, name: "state", kind: "enum", T: proto3.getEnumType(State) },
    { no: 2, name: "ordering", kind: "enum", T: proto3.getEnumType(Order) },
    { no: 3, name: "counterparty", kind: "message", T: Counterparty },
    { no: 4, name: "connection_hops", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 5, name: "version", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ],
);

/**
 * IdentifiedChannel defines a channel with additional port and channel
 * identifier fields.
 *
 * @generated from message ibc.core.channel.v1.IdentifiedChannel
 */
export const IdentifiedChannel = proto3.makeMessageType(
  "ibc.core.channel.v1.IdentifiedChannel",
  () => [
    { no: 1, name: "state", kind: "enum", T: proto3.getEnumType(State) },
    { no: 2, name: "ordering", kind: "enum", T: proto3.getEnumType(Order) },
    { no: 3, name: "counterparty", kind: "message", T: Counterparty },
    { no: 4, name: "connection_hops", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 5, name: "version", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 6, name: "port_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 7, name: "channel_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ],
);

/**
 * Counterparty defines a channel end counterparty
 *
 * @generated from message ibc.core.channel.v1.Counterparty
 */
export const Counterparty = proto3.makeMessageType(
  "ibc.core.channel.v1.Counterparty",
  () => [
    { no: 1, name: "port_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "channel_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ],
);

/**
 * Packet defines a type that carries data across different chains through IBC
 *
 * @generated from message ibc.core.channel.v1.Packet
 */
export const Packet = proto3.makeMessageType(
  "ibc.core.channel.v1.Packet",
  () => [
    { no: 1, name: "sequence", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 2, name: "source_port", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "source_channel", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "destination_port", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "destination_channel", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 6, name: "data", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 7, name: "timeout_height", kind: "message", T: Height },
    { no: 8, name: "timeout_timestamp", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
  ],
);

/**
 * PacketState defines the generic type necessary to retrieve and store
 * packet commitments, acknowledgements, and receipts.
 * Caller is responsible for knowing the context necessary to interpret this
 * state as a commitment, acknowledgement, or a receipt.
 *
 * @generated from message ibc.core.channel.v1.PacketState
 */
export const PacketState = proto3.makeMessageType(
  "ibc.core.channel.v1.PacketState",
  () => [
    { no: 1, name: "port_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "channel_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "sequence", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 4, name: "data", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
  ],
);

/**
 * Acknowledgement is the recommended acknowledgement format to be used by
 * app-specific protocols.
 * NOTE: The field numbers 21 and 22 were explicitly chosen to avoid accidental
 * conflicts with other protobuf message formats used for acknowledgements.
 * The first byte of any message with this format will be the non-ASCII values
 * `0xaa` (result) or `0xb2` (error). Implemented as defined by ICS:
 * https://github.com/cosmos/ibc/tree/master/spec/core/ics-004-channel-and-packet-semantics#acknowledgement-envelope
 *
 * @generated from message ibc.core.channel.v1.Acknowledgement
 */
export const Acknowledgement = proto3.makeMessageType(
  "ibc.core.channel.v1.Acknowledgement",
  () => [
    { no: 21, name: "result", kind: "scalar", T: 12 /* ScalarType.BYTES */, oneof: "response" },
    { no: 22, name: "error", kind: "scalar", T: 9 /* ScalarType.STRING */, oneof: "response" },
  ],
);

