// @generated by protoc-gen-es v0.1.1 with parameter "target=ts"
// @generated from file ibc.proto (package penumbra.ibc, syntax proto3)
/* eslint-disable */
/* @ts-nocheck */

import type {BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage} from "@bufbuild/protobuf";
import {Any, Message, proto3, protoInt64} from "@bufbuild/protobuf";
import {MsgConnectionOpenAck, MsgConnectionOpenConfirm, MsgConnectionOpenInit, MsgConnectionOpenTry} from "./ibc/core/connection/v1/tx_pb.js";
import {MsgAcknowledgement, MsgChannelCloseConfirm, MsgChannelCloseInit, MsgChannelOpenAck, MsgChannelOpenConfirm, MsgChannelOpenInit, MsgChannelOpenTry, MsgRecvPacket, MsgTimeout} from "./ibc/core/channel/v1/tx_pb.js";
import {MsgCreateClient, MsgSubmitMisbehaviour, MsgUpdateClient, MsgUpgradeClient} from "./ibc/core/client/v1/tx_pb.js";
import {Address, Value} from "./crypto_pb.js";
import {Height} from "./ibc/core/client/v1/client_pb.js";

/**
 * @generated from message penumbra.ibc.IBCAction
 */
export class IBCAction extends Message<IBCAction> {
  /**
   * @generated from oneof penumbra.ibc.IBCAction.action
   */
  action: {
    /**
     * @generated from field: ibc.core.connection.v1.MsgConnectionOpenInit connectionOpenInit = 1;
     */
    value: MsgConnectionOpenInit;
    case: "connectionOpenInit";
  } | {
    /**
     * @generated from field: ibc.core.connection.v1.MsgConnectionOpenTry connectionOpenTry = 2;
     */
    value: MsgConnectionOpenTry;
    case: "connectionOpenTry";
  } | {
    /**
     * @generated from field: ibc.core.connection.v1.MsgConnectionOpenAck connectionOpenAck = 3;
     */
    value: MsgConnectionOpenAck;
    case: "connectionOpenAck";
  } | {
    /**
     * @generated from field: ibc.core.connection.v1.MsgConnectionOpenConfirm connectionOpenConfirm = 4;
     */
    value: MsgConnectionOpenConfirm;
    case: "connectionOpenConfirm";
  } | {
    /**
     * @generated from field: ibc.core.channel.v1.MsgChannelOpenInit channelOpenInit = 5;
     */
    value: MsgChannelOpenInit;
    case: "channelOpenInit";
  } | {
    /**
     * @generated from field: ibc.core.channel.v1.MsgChannelOpenTry channelOpenTry = 6;
     */
    value: MsgChannelOpenTry;
    case: "channelOpenTry";
  } | {
    /**
     * @generated from field: ibc.core.channel.v1.MsgChannelOpenAck channelOpenAck = 7;
     */
    value: MsgChannelOpenAck;
    case: "channelOpenAck";
  } | {
    /**
     * @generated from field: ibc.core.channel.v1.MsgChannelOpenConfirm channelOpenConfirm = 8;
     */
    value: MsgChannelOpenConfirm;
    case: "channelOpenConfirm";
  } | {
    /**
     * @generated from field: ibc.core.channel.v1.MsgChannelCloseInit channelCloseInit = 9;
     */
    value: MsgChannelCloseInit;
    case: "channelCloseInit";
  } | {
    /**
     * @generated from field: ibc.core.channel.v1.MsgChannelCloseConfirm channelCloseConfirm = 10;
     */
    value: MsgChannelCloseConfirm;
    case: "channelCloseConfirm";
  } | {
    /**
     * @generated from field: ibc.core.channel.v1.MsgRecvPacket recvPacket = 11;
     */
    value: MsgRecvPacket;
    case: "recvPacket";
  } | {
    /**
     * @generated from field: ibc.core.channel.v1.MsgTimeout timeout = 12;
     */
    value: MsgTimeout;
    case: "timeout";
  } | {
    /**
     * @generated from field: ibc.core.channel.v1.MsgAcknowledgement acknowledgement = 13;
     */
    value: MsgAcknowledgement;
    case: "acknowledgement";
  } | {
    /**
     * @generated from field: ibc.core.client.v1.MsgCreateClient createClient = 14;
     */
    value: MsgCreateClient;
    case: "createClient";
  } | {
    /**
     * @generated from field: ibc.core.client.v1.MsgUpdateClient updateClient = 15;
     */
    value: MsgUpdateClient;
    case: "updateClient";
  } | {
    /**
     * @generated from field: ibc.core.client.v1.MsgUpgradeClient upgradeClient = 16;
     */
    value: MsgUpgradeClient;
    case: "upgradeClient";
  } | {
    /**
     * @generated from field: ibc.core.client.v1.MsgSubmitMisbehaviour submitMisbehaviour = 17;
     */
    value: MsgSubmitMisbehaviour;
    case: "submitMisbehaviour";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<IBCAction>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "penumbra.ibc.IBCAction";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "connectionOpenInit", kind: "message", T: MsgConnectionOpenInit, oneof: "action" },
    { no: 2, name: "connectionOpenTry", kind: "message", T: MsgConnectionOpenTry, oneof: "action" },
    { no: 3, name: "connectionOpenAck", kind: "message", T: MsgConnectionOpenAck, oneof: "action" },
    { no: 4, name: "connectionOpenConfirm", kind: "message", T: MsgConnectionOpenConfirm, oneof: "action" },
    { no: 5, name: "channelOpenInit", kind: "message", T: MsgChannelOpenInit, oneof: "action" },
    { no: 6, name: "channelOpenTry", kind: "message", T: MsgChannelOpenTry, oneof: "action" },
    { no: 7, name: "channelOpenAck", kind: "message", T: MsgChannelOpenAck, oneof: "action" },
    { no: 8, name: "channelOpenConfirm", kind: "message", T: MsgChannelOpenConfirm, oneof: "action" },
    { no: 9, name: "channelCloseInit", kind: "message", T: MsgChannelCloseInit, oneof: "action" },
    { no: 10, name: "channelCloseConfirm", kind: "message", T: MsgChannelCloseConfirm, oneof: "action" },
    { no: 11, name: "recvPacket", kind: "message", T: MsgRecvPacket, oneof: "action" },
    { no: 12, name: "timeout", kind: "message", T: MsgTimeout, oneof: "action" },
    { no: 13, name: "acknowledgement", kind: "message", T: MsgAcknowledgement, oneof: "action" },
    { no: 14, name: "createClient", kind: "message", T: MsgCreateClient, oneof: "action" },
    { no: 15, name: "updateClient", kind: "message", T: MsgUpdateClient, oneof: "action" },
    { no: 16, name: "upgradeClient", kind: "message", T: MsgUpgradeClient, oneof: "action" },
    { no: 17, name: "submitMisbehaviour", kind: "message", T: MsgSubmitMisbehaviour, oneof: "action" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): IBCAction {
    return new IBCAction().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): IBCAction {
    return new IBCAction().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): IBCAction {
    return new IBCAction().fromJsonString(jsonString, options);
  }

  static equals(a: IBCAction | PlainMessage<IBCAction> | undefined, b: IBCAction | PlainMessage<IBCAction> | undefined): boolean {
    return proto3.util.equals(IBCAction, a, b);
  }
}

/**
 * FungibleTokenPacketData defines a struct for the packet payload
 * See FungibleTokenPacketData spec:
 * https://github.com/cosmos/ibc/tree/master/spec/app/ics-020-fungible-token-transfer#data-structures
 *
 * @generated from message penumbra.ibc.FungibleTokenPacketData
 */
export class FungibleTokenPacketData extends Message<FungibleTokenPacketData> {
  /**
   * the token denomination to be transferred
   *
   * @generated from field: string denom = 1;
   */
  denom = "";

  /**
   * the token amount to be transferred
   *
   * @generated from field: string amount = 2;
   */
  amount = "";

  /**
   * the sender address
   *
   * @generated from field: string sender = 3;
   */
  sender = "";

  /**
   * the recipient address on the destination chain
   *
   * @generated from field: string receiver = 4;
   */
  receiver = "";

  constructor(data?: PartialMessage<FungibleTokenPacketData>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "penumbra.ibc.FungibleTokenPacketData";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "denom", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "amount", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "sender", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "receiver", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): FungibleTokenPacketData {
    return new FungibleTokenPacketData().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): FungibleTokenPacketData {
    return new FungibleTokenPacketData().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): FungibleTokenPacketData {
    return new FungibleTokenPacketData().fromJsonString(jsonString, options);
  }

  static equals(a: FungibleTokenPacketData | PlainMessage<FungibleTokenPacketData> | undefined, b: FungibleTokenPacketData | PlainMessage<FungibleTokenPacketData> | undefined): boolean {
    return proto3.util.equals(FungibleTokenPacketData, a, b);
  }
}

/**
 * @generated from message penumbra.ibc.ICS20Withdrawal
 */
export class ICS20Withdrawal extends Message<ICS20Withdrawal> {
  /**
   * the chain ID of the destination chain for this ICS20 transfer
   *
   * @generated from field: string destination_chain_id = 1;
   */
  destinationChainId = "";

  /**
   * a transparent value consisting of an amount and an asset ID.
   *
   * @generated from field: penumbra.crypto.Value value = 2;
   */
  value?: Value;

  /**
   * the address on the destination chain to send the transfer to 
   *
   * @generated from field: string destination_chain_address = 3;
   */
  destinationChainAddress = "";

  /**
   * a "sender" penumbra address to use to return funds from this withdrawal.
   * this should be an ephemeral address
   *
   * @generated from field: penumbra.crypto.Address return_address = 5;
   */
  returnAddress?: Address;

  /**
   * the height (on Penumbra) at which this transfer expires (and funds are sent
   * back to the sender address?). NOTE: if funds are sent back to the sender,
   * we MUST verify a nonexistence proof before accepting the timeout, to
   * prevent relayer censorship attacks. The core IBC implementation does this
   * in its handling of validation of timeouts.
   *
   * @generated from field: uint64 timeout_height = 6;
   */
  timeoutHeight = protoInt64.zero;

  /**
   * the timestamp at which this transfer expires.
   *
   * @generated from field: uint64 timeout_time = 7;
   */
  timeoutTime = protoInt64.zero;

  constructor(data?: PartialMessage<ICS20Withdrawal>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "penumbra.ibc.ICS20Withdrawal";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "destination_chain_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "value", kind: "message", T: Value },
    { no: 3, name: "destination_chain_address", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "return_address", kind: "message", T: Address },
    { no: 6, name: "timeout_height", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 7, name: "timeout_time", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ICS20Withdrawal {
    return new ICS20Withdrawal().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ICS20Withdrawal {
    return new ICS20Withdrawal().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ICS20Withdrawal {
    return new ICS20Withdrawal().fromJsonString(jsonString, options);
  }

  static equals(a: ICS20Withdrawal | PlainMessage<ICS20Withdrawal> | undefined, b: ICS20Withdrawal | PlainMessage<ICS20Withdrawal> | undefined): boolean {
    return proto3.util.equals(ICS20Withdrawal, a, b);
  }
}

/**
 * @generated from message penumbra.ibc.ClientData
 */
export class ClientData extends Message<ClientData> {
  /**
   * @generated from field: string clientID = 1;
   */
  clientID = "";

  /**
   * NOTE: left as Any to allow us to add more client types later
   *
   * @generated from field: google.protobuf.Any clientState = 2;
   */
  clientState?: Any;

  /**
   * @generated from field: string processedTime = 3;
   */
  processedTime = "";

  /**
   * @generated from field: uint64 processedHeight = 4;
   */
  processedHeight = protoInt64.zero;

  constructor(data?: PartialMessage<ClientData>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "penumbra.ibc.ClientData";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "clientID", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "clientState", kind: "message", T: Any },
    { no: 3, name: "processedTime", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "processedHeight", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ClientData {
    return new ClientData().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ClientData {
    return new ClientData().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ClientData {
    return new ClientData().fromJsonString(jsonString, options);
  }

  static equals(a: ClientData | PlainMessage<ClientData> | undefined, b: ClientData | PlainMessage<ClientData> | undefined): boolean {
    return proto3.util.equals(ClientData, a, b);
  }
}

/**
 * @generated from message penumbra.ibc.ClientCounter
 */
export class ClientCounter extends Message<ClientCounter> {
  /**
   * @generated from field: uint64 counter = 1;
   */
  counter = protoInt64.zero;

  constructor(data?: PartialMessage<ClientCounter>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "penumbra.ibc.ClientCounter";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "counter", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ClientCounter {
    return new ClientCounter().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ClientCounter {
    return new ClientCounter().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ClientCounter {
    return new ClientCounter().fromJsonString(jsonString, options);
  }

  static equals(a: ClientCounter | PlainMessage<ClientCounter> | undefined, b: ClientCounter | PlainMessage<ClientCounter> | undefined): boolean {
    return proto3.util.equals(ClientCounter, a, b);
  }
}

/**
 * @generated from message penumbra.ibc.ConsensusState
 */
export class ConsensusState extends Message<ConsensusState> {
  /**
   * @generated from field: google.protobuf.Any consensusState = 1;
   */
  consensusState?: Any;

  constructor(data?: PartialMessage<ConsensusState>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "penumbra.ibc.ConsensusState";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "consensusState", kind: "message", T: Any },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ConsensusState {
    return new ConsensusState().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ConsensusState {
    return new ConsensusState().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ConsensusState {
    return new ConsensusState().fromJsonString(jsonString, options);
  }

  static equals(a: ConsensusState | PlainMessage<ConsensusState> | undefined, b: ConsensusState | PlainMessage<ConsensusState> | undefined): boolean {
    return proto3.util.equals(ConsensusState, a, b);
  }
}

/**
 * @generated from message penumbra.ibc.VerifiedHeights
 */
export class VerifiedHeights extends Message<VerifiedHeights> {
  /**
   * @generated from field: repeated ibc.core.client.v1.Height heights = 1;
   */
  heights: Height[] = [];

  constructor(data?: PartialMessage<VerifiedHeights>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "penumbra.ibc.VerifiedHeights";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "heights", kind: "message", T: Height, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): VerifiedHeights {
    return new VerifiedHeights().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): VerifiedHeights {
    return new VerifiedHeights().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): VerifiedHeights {
    return new VerifiedHeights().fromJsonString(jsonString, options);
  }

  static equals(a: VerifiedHeights | PlainMessage<VerifiedHeights> | undefined, b: VerifiedHeights | PlainMessage<VerifiedHeights> | undefined): boolean {
    return proto3.util.equals(VerifiedHeights, a, b);
  }
}

/**
 * @generated from message penumbra.ibc.ConnectionCounter
 */
export class ConnectionCounter extends Message<ConnectionCounter> {
  /**
   * @generated from field: uint64 counter = 1;
   */
  counter = protoInt64.zero;

  constructor(data?: PartialMessage<ConnectionCounter>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "penumbra.ibc.ConnectionCounter";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "counter", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ConnectionCounter {
    return new ConnectionCounter().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ConnectionCounter {
    return new ConnectionCounter().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ConnectionCounter {
    return new ConnectionCounter().fromJsonString(jsonString, options);
  }

  static equals(a: ConnectionCounter | PlainMessage<ConnectionCounter> | undefined, b: ConnectionCounter | PlainMessage<ConnectionCounter> | undefined): boolean {
    return proto3.util.equals(ConnectionCounter, a, b);
  }
}

/**
 * @generated from message penumbra.ibc.ClientConnections
 */
export class ClientConnections extends Message<ClientConnections> {
  /**
   * @generated from field: repeated string connections = 1;
   */
  connections: string[] = [];

  constructor(data?: PartialMessage<ClientConnections>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "penumbra.ibc.ClientConnections";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "connections", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ClientConnections {
    return new ClientConnections().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ClientConnections {
    return new ClientConnections().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ClientConnections {
    return new ClientConnections().fromJsonString(jsonString, options);
  }

  static equals(a: ClientConnections | PlainMessage<ClientConnections> | undefined, b: ClientConnections | PlainMessage<ClientConnections> | undefined): boolean {
    return proto3.util.equals(ClientConnections, a, b);
  }
}

