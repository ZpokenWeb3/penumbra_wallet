// @generated by protoc-gen-es v0.1.1 with parameter "target=js"
// @generated from file crypto.proto (package penumbra.crypto, syntax proto3)
/* eslint-disable */
/* @ts-nocheck */

import {proto3} from "@bufbuild/protobuf";

/**
 * Specifies fees paid by a transaction.
 *
 * @generated from message penumbra.crypto.Fee
 */
export const Fee = proto3.makeMessageType(
  "penumbra.crypto.Fee",
  () => [
    { no: 1, name: "amount", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 2, name: "asset_id", kind: "message", T: AssetId },
  ],
);

/**
 * @generated from message penumbra.crypto.Address
 */
export const Address = proto3.makeMessageType(
  "penumbra.crypto.Address",
  () => [
    { no: 1, name: "inner", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
  ],
);

/**
 * @generated from message penumbra.crypto.SpendKey
 */
export const SpendKey = proto3.makeMessageType(
  "penumbra.crypto.SpendKey",
  () => [
    { no: 1, name: "inner", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
  ],
);

/**
 * @generated from message penumbra.crypto.SpendVerificationKey
 */
export const SpendVerificationKey = proto3.makeMessageType(
  "penumbra.crypto.SpendVerificationKey",
  () => [
    { no: 1, name: "inner", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
  ],
);

/**
 * @generated from message penumbra.crypto.FullViewingKey
 */
export const FullViewingKey = proto3.makeMessageType(
  "penumbra.crypto.FullViewingKey",
  () => [
    { no: 1, name: "inner", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
  ],
);

/**
 * @generated from message penumbra.crypto.AccountID
 */
export const AccountID = proto3.makeMessageType(
  "penumbra.crypto.AccountID",
  () => [
    { no: 1, name: "inner", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
  ],
);

/**
 * @generated from message penumbra.crypto.Diversifier
 */
export const Diversifier = proto3.makeMessageType(
  "penumbra.crypto.Diversifier",
  () => [
    { no: 1, name: "inner", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
  ],
);

/**
 * @generated from message penumbra.crypto.AddressIndex
 */
export const AddressIndex = proto3.makeMessageType(
  "penumbra.crypto.AddressIndex",
  () => [
    { no: 1, name: "inner", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
  ],
);

/**
 * @generated from message penumbra.crypto.NoteCommitment
 */
export const NoteCommitment = proto3.makeMessageType(
  "penumbra.crypto.NoteCommitment",
  () => [
    { no: 1, name: "inner", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
  ],
);

/**
 * @generated from message penumbra.crypto.ValueCommitment
 */
export const ValueCommitment = proto3.makeMessageType(
  "penumbra.crypto.ValueCommitment",
  () => [
    { no: 1, name: "inner", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
  ],
);

/**
 * @generated from message penumbra.crypto.AssetId
 */
export const AssetId = proto3.makeMessageType(
  "penumbra.crypto.AssetId",
  () => [
    { no: 1, name: "inner", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
  ],
);

/**
 * @generated from message penumbra.crypto.Denom
 */
export const Denom = proto3.makeMessageType(
  "penumbra.crypto.Denom",
  () => [
    { no: 1, name: "denom", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ],
);

/**
 * @generated from message penumbra.crypto.Value
 */
export const Value = proto3.makeMessageType(
  "penumbra.crypto.Value",
  () => [
    { no: 1, name: "amount", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 2, name: "asset_id", kind: "message", T: AssetId },
  ],
);

/**
 * @generated from message penumbra.crypto.MerkleRoot
 */
export const MerkleRoot = proto3.makeMessageType(
  "penumbra.crypto.MerkleRoot",
  () => [
    { no: 1, name: "inner", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
  ],
);

/**
 * @generated from message penumbra.crypto.Asset
 */
export const Asset = proto3.makeMessageType(
  "penumbra.crypto.Asset",
  () => [
    { no: 1, name: "id", kind: "message", T: AssetId },
    { no: 2, name: "denom", kind: "message", T: Denom },
  ],
);

/**
 * A validator's identity key (decaf377-rdsa spendauth verification key).
 *
 * @generated from message penumbra.crypto.IdentityKey
 */
export const IdentityKey = proto3.makeMessageType(
  "penumbra.crypto.IdentityKey",
  () => [
    { no: 1, name: "ik", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
  ],
);

/**
 * A validator's governance key (decaf377-rdsa spendauth verification key).
 *
 * @generated from message penumbra.crypto.GovernanceKey
 */
export const GovernanceKey = proto3.makeMessageType(
  "penumbra.crypto.GovernanceKey",
  () => [
    { no: 1, name: "gk", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
  ],
);

/**
 * @generated from message penumbra.crypto.ConsensusKey
 */
export const ConsensusKey = proto3.makeMessageType(
  "penumbra.crypto.ConsensusKey",
  () => [
    { no: 1, name: "inner", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
  ],
);

/**
 * @generated from message penumbra.crypto.Note
 */
export const Note = proto3.makeMessageType(
  "penumbra.crypto.Note",
  () => [
    { no: 1, name: "value", kind: "message", T: Value },
    { no: 2, name: "note_blinding", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 3, name: "address", kind: "message", T: Address },
  ],
);

/**
 * @generated from message penumbra.crypto.Nullifier
 */
export const Nullifier = proto3.makeMessageType(
  "penumbra.crypto.Nullifier",
  () => [
    { no: 1, name: "inner", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
  ],
);

/**
 * @generated from message penumbra.crypto.SpendAuthSignature
 */
export const SpendAuthSignature = proto3.makeMessageType(
  "penumbra.crypto.SpendAuthSignature",
  () => [
    { no: 1, name: "inner", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
  ],
);

/**
 * @generated from message penumbra.crypto.BindingSignature
 */
export const BindingSignature = proto3.makeMessageType(
  "penumbra.crypto.BindingSignature",
  () => [
    { no: 1, name: "inner", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
  ],
);

/**
 * The body of an output description, including only the minimal
 * data required to scan and process the output.
 *
 * @generated from message penumbra.crypto.NotePayload
 */
export const NotePayload = proto3.makeMessageType(
  "penumbra.crypto.NotePayload",
  () => [
    { no: 1, name: "note_commitment", kind: "message", T: NoteCommitment },
    { no: 2, name: "ephemeral_key", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 3, name: "encrypted_note", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
  ],
);

/**
 * An authentication path from a note commitment to the root of the note commitment tree.
 *
 * @generated from message penumbra.crypto.NoteCommitmentProof
 */
export const NoteCommitmentProof = proto3.makeMessageType(
  "penumbra.crypto.NoteCommitmentProof",
  () => [
    { no: 1, name: "note_commitment", kind: "message", T: NoteCommitment },
    { no: 2, name: "position", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 3, name: "auth_path", kind: "message", T: MerklePathChunk, repeated: true },
  ],
);

/**
 * A set of 3 sibling hashes in the auth path for some note commitment.
 *
 * @generated from message penumbra.crypto.MerklePathChunk
 */
export const MerklePathChunk = proto3.makeMessageType(
  "penumbra.crypto.MerklePathChunk",
  () => [
    { no: 1, name: "sibling_1", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 2, name: "sibling_2", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 3, name: "sibling_3", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
  ],
);

/**
 * A clue for use with Fuzzy Message Detection.
 *
 * @generated from message penumbra.crypto.Clue
 */
export const Clue = proto3.makeMessageType(
  "penumbra.crypto.Clue",
  () => [
    { no: 1, name: "inner", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
  ],
);

