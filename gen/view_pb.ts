// @generated by protoc-gen-es v0.1.1 with parameter "target=ts"
// @generated from file view.proto (package penumbra.view, syntax proto3)
/* eslint-disable */
/* @ts-nocheck */

import type {BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage} from "@bufbuild/protobuf";
import {Message, proto3, protoInt64} from "@bufbuild/protobuf";
import {Transaction} from "./transaction_pb.js";
import {AccountID, AddressIndex, AssetId, IdentityKey, Note, NoteCommitment, Nullifier} from "./crypto_pb.js";
import {NoteSource} from "./chain_pb.js";

/**
 * @generated from message penumbra.view.TransactionsRequest
 */
export class TransactionsRequest extends Message<TransactionsRequest> {
  /**
   * If present, return only transactions after this height.
   *
   * @generated from field: optional uint64 start_height = 1;
   */
  startHeight?: bigint;

  /**
   * If present, return only transactions before this height.
   *
   * @generated from field: optional uint64 end_height = 2;
   */
  endHeight?: bigint;

  constructor(data?: PartialMessage<TransactionsRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "penumbra.view.TransactionsRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "start_height", kind: "scalar", T: 4 /* ScalarType.UINT64 */, opt: true },
    { no: 2, name: "end_height", kind: "scalar", T: 4 /* ScalarType.UINT64 */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TransactionsRequest {
    return new TransactionsRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TransactionsRequest {
    return new TransactionsRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TransactionsRequest {
    return new TransactionsRequest().fromJsonString(jsonString, options);
  }

  static equals(a: TransactionsRequest | PlainMessage<TransactionsRequest> | undefined, b: TransactionsRequest | PlainMessage<TransactionsRequest> | undefined): boolean {
    return proto3.util.equals(TransactionsRequest, a, b);
  }
}

/**
 * @generated from message penumbra.view.TransactionHashStreamResponse
 */
export class TransactionHashStreamResponse extends Message<TransactionHashStreamResponse> {
  /**
   * @generated from field: uint64 block_height = 1;
   */
  blockHeight = protoInt64.zero;

  /**
   * @generated from field: bytes tx_hash = 2;
   */
  txHash = new Uint8Array(0);

  constructor(data?: PartialMessage<TransactionHashStreamResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "penumbra.view.TransactionHashStreamResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "block_height", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 2, name: "tx_hash", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TransactionHashStreamResponse {
    return new TransactionHashStreamResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TransactionHashStreamResponse {
    return new TransactionHashStreamResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TransactionHashStreamResponse {
    return new TransactionHashStreamResponse().fromJsonString(jsonString, options);
  }

  static equals(a: TransactionHashStreamResponse | PlainMessage<TransactionHashStreamResponse> | undefined, b: TransactionHashStreamResponse | PlainMessage<TransactionHashStreamResponse> | undefined): boolean {
    return proto3.util.equals(TransactionHashStreamResponse, a, b);
  }
}

/**
 * A streaming full transaction response
 *
 * @generated from message penumbra.view.TransactionStreamResponse
 */
export class TransactionStreamResponse extends Message<TransactionStreamResponse> {
  /**
   * @generated from field: uint64 block_height = 1;
   */
  blockHeight = protoInt64.zero;

  /**
   * @generated from field: bytes tx_hash = 2;
   */
  txHash = new Uint8Array(0);

  /**
   * @generated from field: penumbra.transaction.Transaction tx = 3;
   */
  tx?: Transaction;

  constructor(data?: PartialMessage<TransactionStreamResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "penumbra.view.TransactionStreamResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "block_height", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 2, name: "tx_hash", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 3, name: "tx", kind: "message", T: Transaction },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TransactionStreamResponse {
    return new TransactionStreamResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TransactionStreamResponse {
    return new TransactionStreamResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TransactionStreamResponse {
    return new TransactionStreamResponse().fromJsonString(jsonString, options);
  }

  static equals(a: TransactionStreamResponse | PlainMessage<TransactionStreamResponse> | undefined, b: TransactionStreamResponse | PlainMessage<TransactionStreamResponse> | undefined): boolean {
    return proto3.util.equals(TransactionStreamResponse, a, b);
  }
}

/**
 * @generated from message penumbra.view.NoteByCommitmentRequest
 */
export class NoteByCommitmentRequest extends Message<NoteByCommitmentRequest> {
  /**
   * @generated from field: penumbra.crypto.AccountID account_id = 1;
   */
  accountId?: AccountID;

  /**
   * @generated from field: penumbra.crypto.NoteCommitment note_commitment = 2;
   */
  noteCommitment?: NoteCommitment;

  /**
   * If set to true, waits to return until the requested note is detected.
   *
   * @generated from field: bool await_detection = 3;
   */
  awaitDetection = false;

  constructor(data?: PartialMessage<NoteByCommitmentRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "penumbra.view.NoteByCommitmentRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "account_id", kind: "message", T: AccountID },
    { no: 2, name: "note_commitment", kind: "message", T: NoteCommitment },
    { no: 3, name: "await_detection", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): NoteByCommitmentRequest {
    return new NoteByCommitmentRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): NoteByCommitmentRequest {
    return new NoteByCommitmentRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): NoteByCommitmentRequest {
    return new NoteByCommitmentRequest().fromJsonString(jsonString, options);
  }

  static equals(a: NoteByCommitmentRequest | PlainMessage<NoteByCommitmentRequest> | undefined, b: NoteByCommitmentRequest | PlainMessage<NoteByCommitmentRequest> | undefined): boolean {
    return proto3.util.equals(NoteByCommitmentRequest, a, b);
  }
}

/**
 * Requests the current chain parameters from the view service.
 *
 * @generated from message penumbra.view.ChainParamsRequest
 */
export class ChainParamsRequest extends Message<ChainParamsRequest> {
  constructor(data?: PartialMessage<ChainParamsRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "penumbra.view.ChainParamsRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ChainParamsRequest {
    return new ChainParamsRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ChainParamsRequest {
    return new ChainParamsRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ChainParamsRequest {
    return new ChainParamsRequest().fromJsonString(jsonString, options);
  }

  static equals(a: ChainParamsRequest | PlainMessage<ChainParamsRequest> | undefined, b: ChainParamsRequest | PlainMessage<ChainParamsRequest> | undefined): boolean {
    return proto3.util.equals(ChainParamsRequest, a, b);
  }
}

/**
 * Requests the current FMD parameters from the view service.
 *
 * @generated from message penumbra.view.FMDParametersRequest
 */
export class FMDParametersRequest extends Message<FMDParametersRequest> {
  constructor(data?: PartialMessage<FMDParametersRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "penumbra.view.FMDParametersRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): FMDParametersRequest {
    return new FMDParametersRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): FMDParametersRequest {
    return new FMDParametersRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): FMDParametersRequest {
    return new FMDParametersRequest().fromJsonString(jsonString, options);
  }

  static equals(a: FMDParametersRequest | PlainMessage<FMDParametersRequest> | undefined, b: FMDParametersRequest | PlainMessage<FMDParametersRequest> | undefined): boolean {
    return proto3.util.equals(FMDParametersRequest, a, b);
  }
}

/**
 * Requests all assets known to the view service.
 *
 * @generated from message penumbra.view.AssetRequest
 */
export class AssetRequest extends Message<AssetRequest> {
  constructor(data?: PartialMessage<AssetRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "penumbra.view.AssetRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AssetRequest {
    return new AssetRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AssetRequest {
    return new AssetRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AssetRequest {
    return new AssetRequest().fromJsonString(jsonString, options);
  }

  static equals(a: AssetRequest | PlainMessage<AssetRequest> | undefined, b: AssetRequest | PlainMessage<AssetRequest> | undefined): boolean {
    return proto3.util.equals(AssetRequest, a, b);
  }
}

/**
 * Requests sync status of the view service.
 *
 * @generated from message penumbra.view.StatusRequest
 */
export class StatusRequest extends Message<StatusRequest> {
  /**
   * Identifies the FVK for the notes to query.
   *
   * @generated from field: penumbra.crypto.AccountID account_id = 1;
   */
  accountId?: AccountID;

  constructor(data?: PartialMessage<StatusRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "penumbra.view.StatusRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "account_id", kind: "message", T: AccountID },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): StatusRequest {
    return new StatusRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): StatusRequest {
    return new StatusRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): StatusRequest {
    return new StatusRequest().fromJsonString(jsonString, options);
  }

  static equals(a: StatusRequest | PlainMessage<StatusRequest> | undefined, b: StatusRequest | PlainMessage<StatusRequest> | undefined): boolean {
    return proto3.util.equals(StatusRequest, a, b);
  }
}

/**
 * Returns the status of the view service and whether it is synchronized with the chain state.
 *
 * @generated from message penumbra.view.StatusResponse
 */
export class StatusResponse extends Message<StatusResponse> {
  /**
   * The height the view service has synchronized to so far
   *
   * @generated from field: uint64 sync_height = 1;
   */
  syncHeight = protoInt64.zero;

  /**
   * Whether the view service is catching up with the chain state
   *
   * @generated from field: bool catching_up = 2;
   */
  catchingUp = false;

  constructor(data?: PartialMessage<StatusResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "penumbra.view.StatusResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "sync_height", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 2, name: "catching_up", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): StatusResponse {
    return new StatusResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): StatusResponse {
    return new StatusResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): StatusResponse {
    return new StatusResponse().fromJsonString(jsonString, options);
  }

  static equals(a: StatusResponse | PlainMessage<StatusResponse> | undefined, b: StatusResponse | PlainMessage<StatusResponse> | undefined): boolean {
    return proto3.util.equals(StatusResponse, a, b);
  }
}

/**
 * Requests streaming updates on the sync height until the view service is synchronized.
 *
 * @generated from message penumbra.view.StatusStreamRequest
 */
export class StatusStreamRequest extends Message<StatusStreamRequest> {
  /**
   * Identifies the FVK for the notes to query.
   *
   * @generated from field: penumbra.crypto.AccountID account_id = 1;
   */
  accountId?: AccountID;

  constructor(data?: PartialMessage<StatusStreamRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "penumbra.view.StatusStreamRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "account_id", kind: "message", T: AccountID },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): StatusStreamRequest {
    return new StatusStreamRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): StatusStreamRequest {
    return new StatusStreamRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): StatusStreamRequest {
    return new StatusStreamRequest().fromJsonString(jsonString, options);
  }

  static equals(a: StatusStreamRequest | PlainMessage<StatusStreamRequest> | undefined, b: StatusStreamRequest | PlainMessage<StatusStreamRequest> | undefined): boolean {
    return proto3.util.equals(StatusStreamRequest, a, b);
  }
}

/**
 * A streaming sync status update
 *
 * @generated from message penumbra.view.StatusStreamResponse
 */
export class StatusStreamResponse extends Message<StatusStreamResponse> {
  /**
   * @generated from field: uint64 latest_known_block_height = 1;
   */
  latestKnownBlockHeight = protoInt64.zero;

  /**
   * @generated from field: uint64 sync_height = 2;
   */
  syncHeight = protoInt64.zero;

  constructor(data?: PartialMessage<StatusStreamResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "penumbra.view.StatusStreamResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "latest_known_block_height", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 2, name: "sync_height", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): StatusStreamResponse {
    return new StatusStreamResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): StatusStreamResponse {
    return new StatusStreamResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): StatusStreamResponse {
    return new StatusStreamResponse().fromJsonString(jsonString, options);
  }

  static equals(a: StatusStreamResponse | PlainMessage<StatusStreamResponse> | undefined, b: StatusStreamResponse | PlainMessage<StatusStreamResponse> | undefined): boolean {
    return proto3.util.equals(StatusStreamResponse, a, b);
  }
}

/**
 * A note plaintext with associated metadata about its status.
 *
 * @generated from message penumbra.view.SpendableNoteRecord
 */
export class SpendableNoteRecord extends Message<SpendableNoteRecord> {
  /**
   * The note commitment, identifying the note.
   *
   * @generated from field: penumbra.crypto.NoteCommitment note_commitment = 1;
   */
  noteCommitment?: NoteCommitment;

  /**
   * The note plaintext itself.
   *
   * @generated from field: penumbra.crypto.Note note = 2;
   */
  note?: Note;

  /**
   * A precomputed decryption of the note's address index.
   *
   * @generated from field: penumbra.crypto.AddressIndex address_index = 3;
   */
  addressIndex?: AddressIndex;

  /**
   * The note's nullifier.
   *
   * @generated from field: penumbra.crypto.Nullifier nullifier = 4;
   */
  nullifier?: Nullifier;

  /**
   * The height at which the note was created.
   *
   * @generated from field: uint64 height_created = 5;
   */
  heightCreated = protoInt64.zero;

  /**
   * Records whether the note was spent (and if so, at what height).
   *
   * @generated from field: optional uint64 height_spent = 6;
   */
  heightSpent?: bigint;

  /**
   * The note position.
   *
   * @generated from field: uint64 position = 7;
   */
  position = protoInt64.zero;

  /**
   * The source of the note (a tx hash or otherwise)
   *
   * @generated from field: penumbra.chain.NoteSource source = 8;
   */
  source?: NoteSource;

  constructor(data?: PartialMessage<SpendableNoteRecord>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "penumbra.view.SpendableNoteRecord";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "note_commitment", kind: "message", T: NoteCommitment },
    { no: 2, name: "note", kind: "message", T: Note },
    { no: 3, name: "address_index", kind: "message", T: AddressIndex },
    { no: 4, name: "nullifier", kind: "message", T: Nullifier },
    { no: 5, name: "height_created", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 6, name: "height_spent", kind: "scalar", T: 4 /* ScalarType.UINT64 */, opt: true },
    { no: 7, name: "position", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 8, name: "source", kind: "message", T: NoteSource },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SpendableNoteRecord {
    return new SpendableNoteRecord().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SpendableNoteRecord {
    return new SpendableNoteRecord().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SpendableNoteRecord {
    return new SpendableNoteRecord().fromJsonString(jsonString, options);
  }

  static equals(a: SpendableNoteRecord | PlainMessage<SpendableNoteRecord> | undefined, b: SpendableNoteRecord | PlainMessage<SpendableNoteRecord> | undefined): boolean {
    return proto3.util.equals(SpendableNoteRecord, a, b);
  }
}

/**
 * A query for notes known by the view service.
 *
 * This message uses the fact that all proto fields are optional
 * to allow various filtering on the returned notes.
 *
 * @generated from message penumbra.view.NotesRequest
 */
export class NotesRequest extends Message<NotesRequest> {
  /**
   * Identifies the FVK for the notes to query.
   *
   * @generated from field: penumbra.crypto.AccountID account_id = 1;
   */
  accountId?: AccountID;

  /**
   * If set, return spent notes as well as unspent notes.
   *
   * @generated from field: bool include_spent = 2;
   */
  includeSpent = false;

  /**
   * If set, only return notes with the specified asset id.
   *
   * @generated from field: penumbra.crypto.AssetId asset_id = 3;
   */
  assetId?: AssetId;

  /**
   * If set, only return notes with the specified address index.
   *
   * @generated from field: penumbra.crypto.AddressIndex address_index = 4;
   */
  addressIndex?: AddressIndex;

  /**
   * If set, stop returning notes once the total exceeds this amount.
   *
   * Ignored if `asset_id` is unset or if `include_spent` is set.
   *
   * @generated from field: uint64 amount_to_spend = 5;
   */
  amountToSpend = protoInt64.zero;

  constructor(data?: PartialMessage<NotesRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "penumbra.view.NotesRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "account_id", kind: "message", T: AccountID },
    { no: 2, name: "include_spent", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 3, name: "asset_id", kind: "message", T: AssetId },
    { no: 4, name: "address_index", kind: "message", T: AddressIndex },
    { no: 5, name: "amount_to_spend", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): NotesRequest {
    return new NotesRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): NotesRequest {
    return new NotesRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): NotesRequest {
    return new NotesRequest().fromJsonString(jsonString, options);
  }

  static equals(a: NotesRequest | PlainMessage<NotesRequest> | undefined, b: NotesRequest | PlainMessage<NotesRequest> | undefined): boolean {
    return proto3.util.equals(NotesRequest, a, b);
  }
}

/**
 * @generated from message penumbra.view.WitnessRequest
 */
export class WitnessRequest extends Message<WitnessRequest> {
  /**
   * Identifies the FVK for the note commitments to query.
   *
   * @generated from field: penumbra.crypto.AccountID account_id = 1;
   */
  accountId?: AccountID;

  /**
   * The note commitments to obtain auth paths for.
   *
   * @generated from field: repeated penumbra.crypto.NoteCommitment note_commitments = 2;
   */
  noteCommitments: NoteCommitment[] = [];

  constructor(data?: PartialMessage<WitnessRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "penumbra.view.WitnessRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "account_id", kind: "message", T: AccountID },
    { no: 2, name: "note_commitments", kind: "message", T: NoteCommitment, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): WitnessRequest {
    return new WitnessRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): WitnessRequest {
    return new WitnessRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): WitnessRequest {
    return new WitnessRequest().fromJsonString(jsonString, options);
  }

  static equals(a: WitnessRequest | PlainMessage<WitnessRequest> | undefined, b: WitnessRequest | PlainMessage<WitnessRequest> | undefined): boolean {
    return proto3.util.equals(WitnessRequest, a, b);
  }
}

/**
 * The plaintext of a note that has been quarantined until the end of an unbonding period.
 *
 * @generated from message penumbra.view.QuarantinedNoteRecord
 */
export class QuarantinedNoteRecord extends Message<QuarantinedNoteRecord> {
  /**
   * The note commitment, identifying the note.
   *
   * @generated from field: penumbra.crypto.NoteCommitment note_commitment = 1;
   */
  noteCommitment?: NoteCommitment;

  /**
   * The note plaintext itself.
   *
   * @generated from field: penumbra.crypto.Note note = 2;
   */
  note?: Note;

  /**
   * A precomputed decryption of the note's address index.
   *
   * @generated from field: penumbra.crypto.AddressIndex address_index = 3;
   */
  addressIndex?: AddressIndex;

  /**
   * The height at which the note was created.
   *
   * @generated from field: uint64 height_created = 4;
   */
  heightCreated = protoInt64.zero;

  /**
   * The epoch at which the note will exit quarantine, if unbonding is not interrupted by slashing.
   *
   * @generated from field: uint64 unbonding_epoch = 5;
   */
  unbondingEpoch = protoInt64.zero;

  /**
   * The validator identity the quarantining is bound to.
   *
   * @generated from field: penumbra.crypto.IdentityKey identity_key = 6;
   */
  identityKey?: IdentityKey;

  /**
   * The source of the note (a tx hash or otherwise)
   *
   * @generated from field: penumbra.chain.NoteSource source = 7;
   */
  source?: NoteSource;

  constructor(data?: PartialMessage<QuarantinedNoteRecord>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "penumbra.view.QuarantinedNoteRecord";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "note_commitment", kind: "message", T: NoteCommitment },
    { no: 2, name: "note", kind: "message", T: Note },
    { no: 3, name: "address_index", kind: "message", T: AddressIndex },
    { no: 4, name: "height_created", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 5, name: "unbonding_epoch", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 6, name: "identity_key", kind: "message", T: IdentityKey },
    { no: 7, name: "source", kind: "message", T: NoteSource },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): QuarantinedNoteRecord {
    return new QuarantinedNoteRecord().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): QuarantinedNoteRecord {
    return new QuarantinedNoteRecord().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): QuarantinedNoteRecord {
    return new QuarantinedNoteRecord().fromJsonString(jsonString, options);
  }

  static equals(a: QuarantinedNoteRecord | PlainMessage<QuarantinedNoteRecord> | undefined, b: QuarantinedNoteRecord | PlainMessage<QuarantinedNoteRecord> | undefined): boolean {
    return proto3.util.equals(QuarantinedNoteRecord, a, b);
  }
}

/**
 * A query for quarantined notes known by the view service.
 *
 * @generated from message penumbra.view.QuarantinedNotesRequest
 */
export class QuarantinedNotesRequest extends Message<QuarantinedNotesRequest> {
  /**
   * Identifies the FVK for the notes to query.
   *
   * @generated from field: penumbra.crypto.AccountID account_id = 1;
   */
  accountId?: AccountID;

  constructor(data?: PartialMessage<QuarantinedNotesRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "penumbra.view.QuarantinedNotesRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "account_id", kind: "message", T: AccountID },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): QuarantinedNotesRequest {
    return new QuarantinedNotesRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): QuarantinedNotesRequest {
    return new QuarantinedNotesRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): QuarantinedNotesRequest {
    return new QuarantinedNotesRequest().fromJsonString(jsonString, options);
  }

  static equals(a: QuarantinedNotesRequest | PlainMessage<QuarantinedNotesRequest> | undefined, b: QuarantinedNotesRequest | PlainMessage<QuarantinedNotesRequest> | undefined): boolean {
    return proto3.util.equals(QuarantinedNotesRequest, a, b);
  }
}

/**
 * @generated from message penumbra.view.NullifierStatusRequest
 */
export class NullifierStatusRequest extends Message<NullifierStatusRequest> {
  /**
   * @generated from field: penumbra.crypto.AccountID account_id = 1;
   */
  accountId?: AccountID;

  /**
   * @generated from field: penumbra.crypto.Nullifier nullifier = 2;
   */
  nullifier?: Nullifier;

  /**
   * @generated from field: bool await_detection = 3;
   */
  awaitDetection = false;

  constructor(data?: PartialMessage<NullifierStatusRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "penumbra.view.NullifierStatusRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "account_id", kind: "message", T: AccountID },
    { no: 2, name: "nullifier", kind: "message", T: Nullifier },
    { no: 3, name: "await_detection", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): NullifierStatusRequest {
    return new NullifierStatusRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): NullifierStatusRequest {
    return new NullifierStatusRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): NullifierStatusRequest {
    return new NullifierStatusRequest().fromJsonString(jsonString, options);
  }

  static equals(a: NullifierStatusRequest | PlainMessage<NullifierStatusRequest> | undefined, b: NullifierStatusRequest | PlainMessage<NullifierStatusRequest> | undefined): boolean {
    return proto3.util.equals(NullifierStatusRequest, a, b);
  }
}

/**
 * @generated from message penumbra.view.NullifierStatusResponse
 */
export class NullifierStatusResponse extends Message<NullifierStatusResponse> {
  /**
   * @generated from field: bool spent = 1;
   */
  spent = false;

  constructor(data?: PartialMessage<NullifierStatusResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "penumbra.view.NullifierStatusResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "spent", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): NullifierStatusResponse {
    return new NullifierStatusResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): NullifierStatusResponse {
    return new NullifierStatusResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): NullifierStatusResponse {
    return new NullifierStatusResponse().fromJsonString(jsonString, options);
  }

  static equals(a: NullifierStatusResponse | PlainMessage<NullifierStatusResponse> | undefined, b: NullifierStatusResponse | PlainMessage<NullifierStatusResponse> | undefined): boolean {
    return proto3.util.equals(NullifierStatusResponse, a, b);
  }
}

