// @generated by protoc-gen-es v0.1.1 with parameter "target=ts"
// @generated from file stake.proto (package penumbra.stake, syntax proto3)
/* eslint-disable */
/* @ts-nocheck */

import type {BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage} from "@bufbuild/protobuf";
import {Message, proto3, protoInt64} from "@bufbuild/protobuf";
import {Address, ConsensusKey, GovernanceKey, IdentityKey} from "./crypto_pb.js";

/**
 * Describes a validator's configuration data.
 *
 * @generated from message penumbra.stake.Validator
 */
export class Validator extends Message<Validator> {
  /**
   * The validator's identity verification key.
   *
   * @generated from field: penumbra.crypto.IdentityKey identity_key = 1;
   */
  identityKey?: IdentityKey;

  /**
   * The validator's consensus pubkey for use in Tendermint (Ed25519).
   *
   * @generated from field: bytes consensus_key = 2;
   */
  consensusKey = new Uint8Array(0);

  /**
   * The validator's (human-readable) name.
   *
   * @generated from field: string name = 3;
   */
  name = "";

  /**
   * The validator's website.
   *
   * @generated from field: string website = 4;
   */
  website = "";

  /**
   * The validator's description.
   *
   * @generated from field: string description = 5;
   */
  description = "";

  /**
   * Whether the validator is enabled or not.
   *
   * Disabled validators cannot be delegated to, and immediately begin unbonding.
   *
   * @generated from field: bool enabled = 8;
   */
  enabled = false;

  /**
   * A list of funding streams describing the validator's commission.
   *
   * @generated from field: repeated penumbra.stake.FundingStream funding_streams = 6;
   */
  fundingStreams: FundingStream[] = [];

  /**
   * The sequence number determines which validator data takes priority, and
   * prevents replay attacks.  The chain only accepts new validator definitions
   * with increasing sequence numbers.
   *
   * @generated from field: uint32 sequence_number = 7;
   */
  sequenceNumber = 0;

  /**
   * The validator's governance key.
   *
   * @generated from field: penumbra.crypto.GovernanceKey governance_key = 9;
   */
  governanceKey?: GovernanceKey;

  constructor(data?: PartialMessage<Validator>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "penumbra.stake.Validator";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "identity_key", kind: "message", T: IdentityKey },
    { no: 2, name: "consensus_key", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 3, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "website", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "description", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 8, name: "enabled", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 6, name: "funding_streams", kind: "message", T: FundingStream, repeated: true },
    { no: 7, name: "sequence_number", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 9, name: "governance_key", kind: "message", T: GovernanceKey },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Validator {
    return new Validator().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Validator {
    return new Validator().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Validator {
    return new Validator().fromJsonString(jsonString, options);
  }

  static equals(a: Validator | PlainMessage<Validator> | undefined, b: Validator | PlainMessage<Validator> | undefined): boolean {
    return proto3.util.equals(Validator, a, b);
  }
}

/**
 * For storing the list of keys of known validators.
 *
 * @generated from message penumbra.stake.ValidatorList
 */
export class ValidatorList extends Message<ValidatorList> {
  /**
   * @generated from field: repeated penumbra.crypto.IdentityKey validator_keys = 1;
   */
  validatorKeys: IdentityKey[] = [];

  constructor(data?: PartialMessage<ValidatorList>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "penumbra.stake.ValidatorList";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "validator_keys", kind: "message", T: IdentityKey, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ValidatorList {
    return new ValidatorList().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ValidatorList {
    return new ValidatorList().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ValidatorList {
    return new ValidatorList().fromJsonString(jsonString, options);
  }

  static equals(a: ValidatorList | PlainMessage<ValidatorList> | undefined, b: ValidatorList | PlainMessage<ValidatorList> | undefined): boolean {
    return proto3.util.equals(ValidatorList, a, b);
  }
}

/**
 * A portion of a validator's commission.
 *
 * @generated from message penumbra.stake.FundingStream
 */
export class FundingStream extends Message<FundingStream> {
  /**
   * The destination address for the funding stream.
   *
   * @generated from field: string address = 1;
   */
  address = "";

  /**
   * The portion of the staking reward for the entire delegation pool
   * allocated to this funding stream, specified in basis points.
   *
   * @generated from field: uint32 rate_bps = 2;
   */
  rateBps = 0;

  constructor(data?: PartialMessage<FundingStream>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "penumbra.stake.FundingStream";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "address", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "rate_bps", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): FundingStream {
    return new FundingStream().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): FundingStream {
    return new FundingStream().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): FundingStream {
    return new FundingStream().fromJsonString(jsonString, options);
  }

  static equals(a: FundingStream | PlainMessage<FundingStream> | undefined, b: FundingStream | PlainMessage<FundingStream> | undefined): boolean {
    return proto3.util.equals(FundingStream, a, b);
  }
}

/**
 * Describes the reward and exchange rates and voting power for a validator in some epoch.
 *
 * @generated from message penumbra.stake.RateData
 */
export class RateData extends Message<RateData> {
  /**
   * @generated from field: penumbra.crypto.IdentityKey identity_key = 1;
   */
  identityKey?: IdentityKey;

  /**
   * @generated from field: uint64 epoch_index = 2;
   */
  epochIndex = protoInt64.zero;

  /**
   * @generated from field: uint64 validator_reward_rate = 4;
   */
  validatorRewardRate = protoInt64.zero;

  /**
   * @generated from field: uint64 validator_exchange_rate = 5;
   */
  validatorExchangeRate = protoInt64.zero;

  constructor(data?: PartialMessage<RateData>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "penumbra.stake.RateData";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "identity_key", kind: "message", T: IdentityKey },
    { no: 2, name: "epoch_index", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 4, name: "validator_reward_rate", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 5, name: "validator_exchange_rate", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RateData {
    return new RateData().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RateData {
    return new RateData().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RateData {
    return new RateData().fromJsonString(jsonString, options);
  }

  static equals(a: RateData | PlainMessage<RateData> | undefined, b: RateData | PlainMessage<RateData> | undefined): boolean {
    return proto3.util.equals(RateData, a, b);
  }
}

/**
 * Describes the base reward and exchange rates in some epoch.
 *
 * @generated from message penumbra.stake.BaseRateData
 */
export class BaseRateData extends Message<BaseRateData> {
  /**
   * @generated from field: uint64 epoch_index = 1;
   */
  epochIndex = protoInt64.zero;

  /**
   * @generated from field: uint64 base_reward_rate = 2;
   */
  baseRewardRate = protoInt64.zero;

  /**
   * @generated from field: uint64 base_exchange_rate = 3;
   */
  baseExchangeRate = protoInt64.zero;

  constructor(data?: PartialMessage<BaseRateData>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "penumbra.stake.BaseRateData";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "epoch_index", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 2, name: "base_reward_rate", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 3, name: "base_exchange_rate", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): BaseRateData {
    return new BaseRateData().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): BaseRateData {
    return new BaseRateData().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): BaseRateData {
    return new BaseRateData().fromJsonString(jsonString, options);
  }

  static equals(a: BaseRateData | PlainMessage<BaseRateData> | undefined, b: BaseRateData | PlainMessage<BaseRateData> | undefined): boolean {
    return proto3.util.equals(BaseRateData, a, b);
  }
}

/**
 * Describes the current state of a validator on-chain
 *
 * @generated from message penumbra.stake.ValidatorStatus
 */
export class ValidatorStatus extends Message<ValidatorStatus> {
  /**
   * @generated from field: penumbra.crypto.IdentityKey identity_key = 1;
   */
  identityKey?: IdentityKey;

  /**
   * @generated from field: penumbra.stake.ValidatorState state = 2;
   */
  state?: ValidatorState;

  /**
   * @generated from field: uint64 voting_power = 3;
   */
  votingPower = protoInt64.zero;

  /**
   * @generated from field: penumbra.stake.BondingState bonding_state = 4;
   */
  bondingState?: BondingState;

  constructor(data?: PartialMessage<ValidatorStatus>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "penumbra.stake.ValidatorStatus";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "identity_key", kind: "message", T: IdentityKey },
    { no: 2, name: "state", kind: "message", T: ValidatorState },
    { no: 3, name: "voting_power", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 4, name: "bonding_state", kind: "message", T: BondingState },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ValidatorStatus {
    return new ValidatorStatus().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ValidatorStatus {
    return new ValidatorStatus().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ValidatorStatus {
    return new ValidatorStatus().fromJsonString(jsonString, options);
  }

  static equals(a: ValidatorStatus | PlainMessage<ValidatorStatus> | undefined, b: ValidatorStatus | PlainMessage<ValidatorStatus> | undefined): boolean {
    return proto3.util.equals(ValidatorStatus, a, b);
  }
}

/**
 * Describes the unbonding state of a validator's stake pool.
 *
 * @generated from message penumbra.stake.BondingState
 */
export class BondingState extends Message<BondingState> {
  /**
   * @generated from field: penumbra.stake.BondingState.BondingStateEnum state = 1;
   */
  state = BondingState_BondingStateEnum.BONDED;

  /**
   * @generated from field: optional uint64 unbonding_epoch = 2;
   */
  unbondingEpoch?: bigint;

  constructor(data?: PartialMessage<BondingState>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "penumbra.stake.BondingState";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "state", kind: "enum", T: proto3.getEnumType(BondingState_BondingStateEnum) },
    { no: 2, name: "unbonding_epoch", kind: "scalar", T: 4 /* ScalarType.UINT64 */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): BondingState {
    return new BondingState().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): BondingState {
    return new BondingState().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): BondingState {
    return new BondingState().fromJsonString(jsonString, options);
  }

  static equals(a: BondingState | PlainMessage<BondingState> | undefined, b: BondingState | PlainMessage<BondingState> | undefined): boolean {
    return proto3.util.equals(BondingState, a, b);
  }
}

/**
 * @generated from enum penumbra.stake.BondingState.BondingStateEnum
 */
export enum BondingState_BondingStateEnum {
  /**
   * @generated from enum value: BONDED = 0;
   */
  BONDED = 0,

  /**
   * @generated from enum value: UNBONDING = 1;
   */
  UNBONDING = 1,

  /**
   * @generated from enum value: UNBONDED = 2;
   */
  UNBONDED = 2,
}
// Retrieve enum metadata with: proto3.getEnumType(BondingState_BondingStateEnum)
proto3.util.setEnumType(BondingState_BondingStateEnum, "penumbra.stake.BondingState.BondingStateEnum", [
  { no: 0, name: "BONDED" },
  { no: 1, name: "UNBONDING" },
  { no: 2, name: "UNBONDED" },
]);

/**
 * Describes the state of a validator
 *
 * @generated from message penumbra.stake.ValidatorState
 */
export class ValidatorState extends Message<ValidatorState> {
  /**
   * @generated from field: penumbra.stake.ValidatorState.ValidatorStateEnum state = 1;
   */
  state = ValidatorState_ValidatorStateEnum.INACTIVE;

  constructor(data?: PartialMessage<ValidatorState>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "penumbra.stake.ValidatorState";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "state", kind: "enum", T: proto3.getEnumType(ValidatorState_ValidatorStateEnum) },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ValidatorState {
    return new ValidatorState().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ValidatorState {
    return new ValidatorState().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ValidatorState {
    return new ValidatorState().fromJsonString(jsonString, options);
  }

  static equals(a: ValidatorState | PlainMessage<ValidatorState> | undefined, b: ValidatorState | PlainMessage<ValidatorState> | undefined): boolean {
    return proto3.util.equals(ValidatorState, a, b);
  }
}

/**
 * @generated from enum penumbra.stake.ValidatorState.ValidatorStateEnum
 */
export enum ValidatorState_ValidatorStateEnum {
  /**
   * @generated from enum value: INACTIVE = 0;
   */
  INACTIVE = 0,

  /**
   * @generated from enum value: ACTIVE = 1;
   */
  ACTIVE = 1,

  /**
   * @generated from enum value: JAILED = 2;
   */
  JAILED = 2,

  /**
   * @generated from enum value: TOMBSTONED = 3;
   */
  TOMBSTONED = 3,

  /**
   * @generated from enum value: DISABLED = 4;
   */
  DISABLED = 4,
}
// Retrieve enum metadata with: proto3.getEnumType(ValidatorState_ValidatorStateEnum)
proto3.util.setEnumType(ValidatorState_ValidatorStateEnum, "penumbra.stake.ValidatorState.ValidatorStateEnum", [
  { no: 0, name: "INACTIVE" },
  { no: 1, name: "ACTIVE" },
  { no: 2, name: "JAILED" },
  { no: 3, name: "TOMBSTONED" },
  { no: 4, name: "DISABLED" },
]);

/**
 * Combines all validator info into a single packet.
 *
 * @generated from message penumbra.stake.ValidatorInfo
 */
export class ValidatorInfo extends Message<ValidatorInfo> {
  /**
   * @generated from field: penumbra.stake.Validator validator = 1;
   */
  validator?: Validator;

  /**
   * @generated from field: penumbra.stake.ValidatorStatus status = 2;
   */
  status?: ValidatorStatus;

  /**
   * @generated from field: penumbra.stake.RateData rate_data = 3;
   */
  rateData?: RateData;

  constructor(data?: PartialMessage<ValidatorInfo>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "penumbra.stake.ValidatorInfo";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "validator", kind: "message", T: Validator },
    { no: 2, name: "status", kind: "message", T: ValidatorStatus },
    { no: 3, name: "rate_data", kind: "message", T: RateData },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ValidatorInfo {
    return new ValidatorInfo().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ValidatorInfo {
    return new ValidatorInfo().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ValidatorInfo {
    return new ValidatorInfo().fromJsonString(jsonString, options);
  }

  static equals(a: ValidatorInfo | PlainMessage<ValidatorInfo> | undefined, b: ValidatorInfo | PlainMessage<ValidatorInfo> | undefined): boolean {
    return proto3.util.equals(ValidatorInfo, a, b);
  }
}

/**
 * A transaction action (re)defining a validator.
 *
 * @generated from message penumbra.stake.ValidatorDefinition
 */
export class ValidatorDefinition extends Message<ValidatorDefinition> {
  /**
   * The configuration data for the validator.
   *
   * @generated from field: penumbra.stake.Validator validator = 1;
   */
  validator?: Validator;

  /**
   * A signature by the validator's identity key over the validator data.
   *
   * @generated from field: bytes auth_sig = 2;
   */
  authSig = new Uint8Array(0);

  constructor(data?: PartialMessage<ValidatorDefinition>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "penumbra.stake.ValidatorDefinition";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "validator", kind: "message", T: Validator },
    { no: 2, name: "auth_sig", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ValidatorDefinition {
    return new ValidatorDefinition().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ValidatorDefinition {
    return new ValidatorDefinition().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ValidatorDefinition {
    return new ValidatorDefinition().fromJsonString(jsonString, options);
  }

  static equals(a: ValidatorDefinition | PlainMessage<ValidatorDefinition> | undefined, b: ValidatorDefinition | PlainMessage<ValidatorDefinition> | undefined): boolean {
    return proto3.util.equals(ValidatorDefinition, a, b);
  }
}

/**
 * A transaction action adding stake to a validator's delegation pool.
 *
 * @generated from message penumbra.stake.Delegate
 */
export class Delegate extends Message<Delegate> {
  /**
   * The identity key of the validator to delegate to.
   *
   * @generated from field: penumbra.crypto.IdentityKey validator_identity = 1;
   */
  validatorIdentity?: IdentityKey;

  /**
   * The index of the epoch in which this delegation was performed.
   * The delegation takes effect in the next epoch.
   *
   * @generated from field: uint64 epoch_index = 2;
   */
  epochIndex = protoInt64.zero;

  /**
   * The delegation amount, in units of unbonded stake.
   * TODO: use flow aggregation to hide this, replacing it with bytes amount_ciphertext;
   *
   * @generated from field: uint64 unbonded_amount = 3;
   */
  unbondedAmount = protoInt64.zero;

  /**
   * The amount of delegation tokens produced by this action.
   *
   * This is implied by the validator's exchange rate in the specified epoch
   * (and should be checked in transaction validation!), but including it allows
   * stateless verification that the transaction is internally consistent.
   *
   * @generated from field: uint64 delegation_amount = 4;
   */
  delegationAmount = protoInt64.zero;

  constructor(data?: PartialMessage<Delegate>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "penumbra.stake.Delegate";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "validator_identity", kind: "message", T: IdentityKey },
    { no: 2, name: "epoch_index", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 3, name: "unbonded_amount", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 4, name: "delegation_amount", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Delegate {
    return new Delegate().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Delegate {
    return new Delegate().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Delegate {
    return new Delegate().fromJsonString(jsonString, options);
  }

  static equals(a: Delegate | PlainMessage<Delegate> | undefined, b: Delegate | PlainMessage<Delegate> | undefined): boolean {
    return proto3.util.equals(Delegate, a, b);
  }
}

/**
 * A transaction action withdrawing stake from a validator's delegation pool.
 *
 * @generated from message penumbra.stake.Undelegate
 */
export class Undelegate extends Message<Undelegate> {
  /**
   * The identity key of the validator to undelegate from.
   *
   * @generated from field: penumbra.crypto.IdentityKey validator_identity = 1;
   */
  validatorIdentity?: IdentityKey;

  /**
   * The index of the epoch in which this undelegation was performed.
   *
   * @generated from field: uint64 epoch_index = 2;
   */
  epochIndex = protoInt64.zero;

  /**
   * The amount to undelegate, in units of unbonded stake.
   *
   * @generated from field: uint64 unbonded_amount = 3;
   */
  unbondedAmount = protoInt64.zero;

  /**
   * The amount of delegation tokens consumed by this action.
   *
   * This is implied by the validator's exchange rate in the specified epoch
   * (and should be checked in transaction validation!), but including it allows
   * stateless verification that the transaction is internally consistent.
   *
   * @generated from field: uint64 delegation_amount = 4;
   */
  delegationAmount = protoInt64.zero;

  constructor(data?: PartialMessage<Undelegate>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "penumbra.stake.Undelegate";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "validator_identity", kind: "message", T: IdentityKey },
    { no: 2, name: "epoch_index", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 3, name: "unbonded_amount", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 4, name: "delegation_amount", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Undelegate {
    return new Undelegate().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Undelegate {
    return new Undelegate().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Undelegate {
    return new Undelegate().fromJsonString(jsonString, options);
  }

  static equals(a: Undelegate | PlainMessage<Undelegate> | undefined, b: Undelegate | PlainMessage<Undelegate> | undefined): boolean {
    return proto3.util.equals(Undelegate, a, b);
  }
}

/**
 * A commission amount to be minted as part of processing the epoch transition.
 *
 * @generated from message penumbra.stake.CommissionAmount
 */
export class CommissionAmount extends Message<CommissionAmount> {
  /**
   * @generated from field: uint64 amount = 1;
   */
  amount = protoInt64.zero;

  /**
   * @generated from field: penumbra.crypto.Address destination = 2;
   */
  destination?: Address;

  constructor(data?: PartialMessage<CommissionAmount>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "penumbra.stake.CommissionAmount";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "amount", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 2, name: "destination", kind: "message", T: Address },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CommissionAmount {
    return new CommissionAmount().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CommissionAmount {
    return new CommissionAmount().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CommissionAmount {
    return new CommissionAmount().fromJsonString(jsonString, options);
  }

  static equals(a: CommissionAmount | PlainMessage<CommissionAmount> | undefined, b: CommissionAmount | PlainMessage<CommissionAmount> | undefined): boolean {
    return proto3.util.equals(CommissionAmount, a, b);
  }
}

/**
 * A list of commission amounts to be minted as part of processing the epoch transition.
 *
 * @generated from message penumbra.stake.CommissionAmounts
 */
export class CommissionAmounts extends Message<CommissionAmounts> {
  /**
   * @generated from field: repeated penumbra.stake.CommissionAmount notes = 1;
   */
  notes: CommissionAmount[] = [];

  constructor(data?: PartialMessage<CommissionAmounts>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "penumbra.stake.CommissionAmounts";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "notes", kind: "message", T: CommissionAmount, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CommissionAmounts {
    return new CommissionAmounts().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CommissionAmounts {
    return new CommissionAmounts().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CommissionAmounts {
    return new CommissionAmounts().fromJsonString(jsonString, options);
  }

  static equals(a: CommissionAmounts | PlainMessage<CommissionAmounts> | undefined, b: CommissionAmounts | PlainMessage<CommissionAmounts> | undefined): boolean {
    return proto3.util.equals(CommissionAmounts, a, b);
  }
}

/**
 * A list of pending delegations and undelegations.
 *
 * @generated from message penumbra.stake.DelegationChanges
 */
export class DelegationChanges extends Message<DelegationChanges> {
  /**
   * @generated from field: repeated penumbra.stake.Delegate delegations = 1;
   */
  delegations: Delegate[] = [];

  /**
   * @generated from field: repeated penumbra.stake.Undelegate undelegations = 2;
   */
  undelegations: Undelegate[] = [];

  constructor(data?: PartialMessage<DelegationChanges>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "penumbra.stake.DelegationChanges";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "delegations", kind: "message", T: Delegate, repeated: true },
    { no: 2, name: "undelegations", kind: "message", T: Undelegate, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DelegationChanges {
    return new DelegationChanges().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DelegationChanges {
    return new DelegationChanges().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DelegationChanges {
    return new DelegationChanges().fromJsonString(jsonString, options);
  }

  static equals(a: DelegationChanges | PlainMessage<DelegationChanges> | undefined, b: DelegationChanges | PlainMessage<DelegationChanges> | undefined): boolean {
    return proto3.util.equals(DelegationChanges, a, b);
  }
}

/**
 * Track's a validator's uptime.
 *
 * @generated from message penumbra.stake.Uptime
 */
export class Uptime extends Message<Uptime> {
  /**
   * @generated from field: uint64 as_of_block_height = 1;
   */
  asOfBlockHeight = protoInt64.zero;

  /**
   * @generated from field: uint32 window_len = 2;
   */
  windowLen = 0;

  /**
   * @generated from field: bytes bitvec = 3;
   */
  bitvec = new Uint8Array(0);

  constructor(data?: PartialMessage<Uptime>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "penumbra.stake.Uptime";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "as_of_block_height", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 2, name: "window_len", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 3, name: "bitvec", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Uptime {
    return new Uptime().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Uptime {
    return new Uptime().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Uptime {
    return new Uptime().fromJsonString(jsonString, options);
  }

  static equals(a: Uptime | PlainMessage<Uptime> | undefined, b: Uptime | PlainMessage<Uptime> | undefined): boolean {
    return proto3.util.equals(Uptime, a, b);
  }
}

/**
 * Tracks our view of Tendermint's view of the validator set, so we can keep it
 * from getting confused.
 *
 * @generated from message penumbra.stake.CurrentConsensusKeys
 */
export class CurrentConsensusKeys extends Message<CurrentConsensusKeys> {
  /**
   * @generated from field: repeated penumbra.crypto.ConsensusKey consensus_keys = 1;
   */
  consensusKeys: ConsensusKey[] = [];

  constructor(data?: PartialMessage<CurrentConsensusKeys>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "penumbra.stake.CurrentConsensusKeys";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "consensus_keys", kind: "message", T: ConsensusKey, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CurrentConsensusKeys {
    return new CurrentConsensusKeys().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CurrentConsensusKeys {
    return new CurrentConsensusKeys().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CurrentConsensusKeys {
    return new CurrentConsensusKeys().fromJsonString(jsonString, options);
  }

  static equals(a: CurrentConsensusKeys | PlainMessage<CurrentConsensusKeys> | undefined, b: CurrentConsensusKeys | PlainMessage<CurrentConsensusKeys> | undefined): boolean {
    return proto3.util.equals(CurrentConsensusKeys, a, b);
  }
}

