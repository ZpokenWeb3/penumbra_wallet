// @generated by protoc-gen-es v0.1.1 with parameter "target=ts"
// @generated from file chain.proto (package penumbra.chain, syntax proto3)
/* eslint-disable */
/* @ts-nocheck */

import type {BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage} from "@bufbuild/protobuf";
import {Message, proto3, protoInt64} from "@bufbuild/protobuf";
import {Address, Asset, AssetId, Denom, IdentityKey, MerkleRoot, NotePayload, Nullifier} from "./crypto_pb.js";
import {Validator} from "./stake_pb.js";

/**
 * Global chain configuration data, such as chain ID, epoch duration, etc.
 *
 * @generated from message penumbra.chain.ChainParameters
 */
export class ChainParameters extends Message<ChainParameters> {
  /**
   * The identifier of the chain.
   *
   * @generated from field: string chain_id = 1;
   */
  chainId = "";

  /**
   * The duration of each epoch, in number of blocks.
   *
   * @generated from field: uint64 epoch_duration = 2;
   */
  epochDuration = protoInt64.zero;

  /**
   * The number of epochs an unbonding note for before being released.
   *
   * @generated from field: uint64 unbonding_epochs = 3;
   */
  unbondingEpochs = protoInt64.zero;

  /**
   * The maximum number of validators in the consensus set.
   *
   * @generated from field: uint64 active_validator_limit = 4;
   */
  activeValidatorLimit = protoInt64.zero;

  /**
   * The base reward rate, expressed in basis points of basis points
   *
   * @generated from field: uint64 base_reward_rate = 9;
   */
  baseRewardRate = protoInt64.zero;

  /**
   * The penalty for slashing due to misbehavior, expressed in basis points.
   *
   * @generated from field: uint64 slashing_penalty_misbehavior_bps = 5;
   */
  slashingPenaltyMisbehaviorBps = protoInt64.zero;

  /**
   * The penalty for slashing due to downtime, expressed in basis points.
   *
   * @generated from field: uint64 slashing_penalty_downtime_bps = 10;
   */
  slashingPenaltyDowntimeBps = protoInt64.zero;

  /**
   * The number of blocks in the window to check for downtime.
   *
   * @generated from field: uint64 signed_blocks_window_len = 11;
   */
  signedBlocksWindowLen = protoInt64.zero;

  /**
   * The maximum number of blocks in the window each validator can miss signing without slashing.
   *
   * @generated from field: uint64 missed_blocks_maximum = 12;
   */
  missedBlocksMaximum = protoInt64.zero;

  /**
   * Whether IBC (forming connections, processing IBC packets) is enabled.
   *
   * @generated from field: bool ibc_enabled = 6;
   */
  ibcEnabled = false;

  /**
   * Whether inbound ICS-20 transfers are enabled
   *
   * @generated from field: bool inbound_ics20_transfers_enabled = 7;
   */
  inboundIcs20TransfersEnabled = false;

  /**
   * Whether outbound ICS-20 transfers are enabled
   *
   * @generated from field: bool outbound_ics20_transfers_enabled = 8;
   */
  outboundIcs20TransfersEnabled = false;

  /**
   * The number of blocks during which a proposal is voted on.
   *
   * @generated from field: uint64 proposal_voting_blocks = 20;
   */
  proposalVotingBlocks = protoInt64.zero;

  /**
   * The deposit required to create a proposal.
   *
   * @generated from field: uint64 proposal_deposit_amount = 21;
   */
  proposalDepositAmount = protoInt64.zero;

  /**
   * The quorum required for a proposal to be considered valid, as a fraction of the total stake
   * weight of the network.
   *
   * @generated from field: penumbra.chain.Ratio proposal_valid_quorum = 22;
   */
  proposalValidQuorum?: Ratio;

  /**
   * The threshold for a proposal to pass voting, as a ratio of "yes" votes over "no" votes.
   *
   * @generated from field: penumbra.chain.Ratio proposal_pass_threshold = 23;
   */
  proposalPassThreshold?: Ratio;

  /**
   * The threshold for a proposal to be vetoed, regardless of whether the "yes" and "no" votes would
   * have passed it, as a ratio of "no with veto" votes over all total votes.
   *
   * @generated from field: penumbra.chain.Ratio proposal_veto_threshold = 24;
   */
  proposalVetoThreshold?: Ratio;

  constructor(data?: PartialMessage<ChainParameters>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "penumbra.chain.ChainParameters";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "chain_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "epoch_duration", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 3, name: "unbonding_epochs", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 4, name: "active_validator_limit", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 9, name: "base_reward_rate", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 5, name: "slashing_penalty_misbehavior_bps", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 10, name: "slashing_penalty_downtime_bps", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 11, name: "signed_blocks_window_len", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 12, name: "missed_blocks_maximum", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 6, name: "ibc_enabled", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 7, name: "inbound_ics20_transfers_enabled", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 8, name: "outbound_ics20_transfers_enabled", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 20, name: "proposal_voting_blocks", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 21, name: "proposal_deposit_amount", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 22, name: "proposal_valid_quorum", kind: "message", T: Ratio },
    { no: 23, name: "proposal_pass_threshold", kind: "message", T: Ratio },
    { no: 24, name: "proposal_veto_threshold", kind: "message", T: Ratio },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ChainParameters {
    return new ChainParameters().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ChainParameters {
    return new ChainParameters().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ChainParameters {
    return new ChainParameters().fromJsonString(jsonString, options);
  }

  static equals(a: ChainParameters | PlainMessage<ChainParameters> | undefined, b: ChainParameters | PlainMessage<ChainParameters> | undefined): boolean {
    return proto3.util.equals(ChainParameters, a, b);
  }
}

/**
 * The ratio between two numbers, used in governance to describe vote thresholds and quorums.
 *
 * @generated from message penumbra.chain.Ratio
 */
export class Ratio extends Message<Ratio> {
  /**
   * The numerator.
   *
   * @generated from field: uint64 numerator = 1;
   */
  numerator = protoInt64.zero;

  /**
   * The denominator.
   *
   * @generated from field: uint64 denominator = 2;
   */
  denominator = protoInt64.zero;

  constructor(data?: PartialMessage<Ratio>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "penumbra.chain.Ratio";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "numerator", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 2, name: "denominator", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Ratio {
    return new Ratio().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Ratio {
    return new Ratio().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Ratio {
    return new Ratio().fromJsonString(jsonString, options);
  }

  static equals(a: Ratio | PlainMessage<Ratio> | undefined, b: Ratio | PlainMessage<Ratio> | undefined): boolean {
    return proto3.util.equals(Ratio, a, b);
  }
}

/**
 * Parameters for Fuzzy Message Detection
 *
 * @generated from message penumbra.chain.FmdParameters
 */
export class FmdParameters extends Message<FmdParameters> {
  /**
   * @generated from field: uint32 precision_bits = 1;
   */
  precisionBits = 0;

  /**
   * @generated from field: uint64 as_of_block_height = 2;
   */
  asOfBlockHeight = protoInt64.zero;

  constructor(data?: PartialMessage<FmdParameters>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "penumbra.chain.FmdParameters";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "precision_bits", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 2, name: "as_of_block_height", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): FmdParameters {
    return new FmdParameters().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): FmdParameters {
    return new FmdParameters().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): FmdParameters {
    return new FmdParameters().fromJsonString(jsonString, options);
  }

  static equals(a: FmdParameters | PlainMessage<FmdParameters> | undefined, b: FmdParameters | PlainMessage<FmdParameters> | undefined): boolean {
    return proto3.util.equals(FmdParameters, a, b);
  }
}

/**
 * TODO: delete with legacy code
 * Information about a given asset at a given time (as specified by block
 * height). Currently this only contains the total supply.
 *
 * @generated from message penumbra.chain.AssetInfo
 */
export class AssetInfo extends Message<AssetInfo> {
  /**
   * @generated from field: penumbra.crypto.AssetId asset_id = 1;
   */
  assetId?: AssetId;

  /**
   * @generated from field: penumbra.crypto.Denom denom = 2;
   */
  denom?: Denom;

  /**
   * @generated from field: uint64 as_of_block_height = 3;
   */
  asOfBlockHeight = protoInt64.zero;

  /**
   * @generated from field: uint64 total_supply = 4;
   */
  totalSupply = protoInt64.zero;

  constructor(data?: PartialMessage<AssetInfo>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "penumbra.chain.AssetInfo";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "asset_id", kind: "message", T: AssetId },
    { no: 2, name: "denom", kind: "message", T: Denom },
    { no: 3, name: "as_of_block_height", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 4, name: "total_supply", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AssetInfo {
    return new AssetInfo().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AssetInfo {
    return new AssetInfo().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AssetInfo {
    return new AssetInfo().fromJsonString(jsonString, options);
  }

  static equals(a: AssetInfo | PlainMessage<AssetInfo> | undefined, b: AssetInfo | PlainMessage<AssetInfo> | undefined): boolean {
    return proto3.util.equals(AssetInfo, a, b);
  }
}

/**
 * Contains the minimum data needed to update client state.
 *
 * @generated from message penumbra.chain.CompactBlock
 */
export class CompactBlock extends Message<CompactBlock> {
  /**
   * @generated from field: uint64 height = 1;
   */
  height = protoInt64.zero;

  /**
   * NotePayloads describing new notes.
   *
   * @generated from field: repeated penumbra.chain.AnnotatedNotePayload note_payloads = 2;
   */
  notePayloads: AnnotatedNotePayload[] = [];

  /**
   * Nullifiers identifying spent notes.
   *
   * @generated from field: repeated penumbra.crypto.Nullifier nullifiers = 3;
   */
  nullifiers: Nullifier[] = [];

  /**
   * The block root of this block.
   *
   * @generated from field: penumbra.crypto.MerkleRoot block_root = 4;
   */
  blockRoot?: MerkleRoot;

  /**
   * The epoch root of this epoch (only present when the block is the last in an epoch).
   *
   * @generated from field: penumbra.crypto.MerkleRoot epoch_root = 5;
   */
  epochRoot?: MerkleRoot;

  /**
   * Newly quarantined things in this block.
   *
   * @generated from field: penumbra.chain.Quarantined quarantined = 6;
   */
  quarantined?: Quarantined;

  /**
   * Validators slashed in this block.
   *
   * @generated from field: repeated penumbra.crypto.IdentityKey slashed = 16;
   */
  slashed: IdentityKey[] = [];

  /**
   * If a proposal started voting in this block, this is set to `true`.
   *
   * @generated from field: bool proposal_started = 20;
   */
  proposalStarted = false;

  /**
   * Latest Fuzzy Message Detection parameters.
   *
   * @generated from field: penumbra.chain.FmdParameters fmd_parameters = 100;
   */
  fmdParameters?: FmdParameters;

  constructor(data?: PartialMessage<CompactBlock>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "penumbra.chain.CompactBlock";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "height", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 2, name: "note_payloads", kind: "message", T: AnnotatedNotePayload, repeated: true },
    { no: 3, name: "nullifiers", kind: "message", T: Nullifier, repeated: true },
    { no: 4, name: "block_root", kind: "message", T: MerkleRoot },
    { no: 5, name: "epoch_root", kind: "message", T: MerkleRoot },
    { no: 6, name: "quarantined", kind: "message", T: Quarantined },
    { no: 16, name: "slashed", kind: "message", T: IdentityKey, repeated: true },
    { no: 20, name: "proposal_started", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 100, name: "fmd_parameters", kind: "message", T: FmdParameters },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CompactBlock {
    return new CompactBlock().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CompactBlock {
    return new CompactBlock().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CompactBlock {
    return new CompactBlock().fromJsonString(jsonString, options);
  }

  static equals(a: CompactBlock | PlainMessage<CompactBlock> | undefined, b: CompactBlock | PlainMessage<CompactBlock> | undefined): boolean {
    return proto3.util.equals(CompactBlock, a, b);
  }
}

/**
 * A note payload, annotated with the note source.
 *
 * @generated from message penumbra.chain.AnnotatedNotePayload
 */
export class AnnotatedNotePayload extends Message<AnnotatedNotePayload> {
  /**
   * @generated from field: penumbra.crypto.NotePayload payload = 1;
   */
  payload?: NotePayload;

  /**
   * @generated from field: penumbra.chain.NoteSource source = 2;
   */
  source?: NoteSource;

  constructor(data?: PartialMessage<AnnotatedNotePayload>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "penumbra.chain.AnnotatedNotePayload";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "payload", kind: "message", T: NotePayload },
    { no: 2, name: "source", kind: "message", T: NoteSource },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AnnotatedNotePayload {
    return new AnnotatedNotePayload().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AnnotatedNotePayload {
    return new AnnotatedNotePayload().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AnnotatedNotePayload {
    return new AnnotatedNotePayload().fromJsonString(jsonString, options);
  }

  static equals(a: AnnotatedNotePayload | PlainMessage<AnnotatedNotePayload> | undefined, b: AnnotatedNotePayload | PlainMessage<AnnotatedNotePayload> | undefined): boolean {
    return proto3.util.equals(AnnotatedNotePayload, a, b);
  }
}

/**
 * @generated from message penumbra.chain.KnownAssets
 */
export class KnownAssets extends Message<KnownAssets> {
  /**
   * @generated from field: repeated penumbra.crypto.Asset assets = 1;
   */
  assets: Asset[] = [];

  constructor(data?: PartialMessage<KnownAssets>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "penumbra.chain.KnownAssets";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "assets", kind: "message", T: Asset, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): KnownAssets {
    return new KnownAssets().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): KnownAssets {
    return new KnownAssets().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): KnownAssets {
    return new KnownAssets().fromJsonString(jsonString, options);
  }

  static equals(a: KnownAssets | PlainMessage<KnownAssets> | undefined, b: KnownAssets | PlainMessage<KnownAssets> | undefined): boolean {
    return proto3.util.equals(KnownAssets, a, b);
  }
}

/**
 * A spicy transaction ID
 *
 * @generated from message penumbra.chain.NoteSource
 */
export class NoteSource extends Message<NoteSource> {
  /**
   * @generated from field: bytes inner = 1;
   */
  inner = new Uint8Array(0);

  constructor(data?: PartialMessage<NoteSource>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "penumbra.chain.NoteSource";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "inner", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): NoteSource {
    return new NoteSource().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): NoteSource {
    return new NoteSource().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): NoteSource {
    return new NoteSource().fromJsonString(jsonString, options);
  }

  static equals(a: NoteSource | PlainMessage<NoteSource> | undefined, b: NoteSource | PlainMessage<NoteSource> | undefined): boolean {
    return proto3.util.equals(NoteSource, a, b);
  }
}

/**
 * A spicier transaction ID: one which can be missing
 *
 * @generated from message penumbra.chain.DelibleNoteSource
 */
export class DelibleNoteSource extends Message<DelibleNoteSource> {
  /**
   * @generated from field: penumbra.chain.NoteSource source = 1;
   */
  source?: NoteSource;

  constructor(data?: PartialMessage<DelibleNoteSource>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "penumbra.chain.DelibleNoteSource";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "source", kind: "message", T: NoteSource },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DelibleNoteSource {
    return new DelibleNoteSource().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DelibleNoteSource {
    return new DelibleNoteSource().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DelibleNoteSource {
    return new DelibleNoteSource().fromJsonString(jsonString, options);
  }

  static equals(a: DelibleNoteSource | PlainMessage<DelibleNoteSource> | undefined, b: DelibleNoteSource | PlainMessage<DelibleNoteSource> | undefined): boolean {
    return proto3.util.equals(DelibleNoteSource, a, b);
  }
}

/**
 * @generated from message penumbra.chain.GenesisAppState
 */
export class GenesisAppState extends Message<GenesisAppState> {
  /**
   * @generated from field: penumbra.chain.ChainParameters chain_params = 1;
   */
  chainParams?: ChainParameters;

  /**
   * @generated from field: repeated penumbra.stake.Validator validators = 2;
   */
  validators: Validator[] = [];

  /**
   * @generated from field: repeated penumbra.chain.GenesisAppState.Allocation allocations = 3;
   */
  allocations: GenesisAppState_Allocation[] = [];

  constructor(data?: PartialMessage<GenesisAppState>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "penumbra.chain.GenesisAppState";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "chain_params", kind: "message", T: ChainParameters },
    { no: 2, name: "validators", kind: "message", T: Validator, repeated: true },
    { no: 3, name: "allocations", kind: "message", T: GenesisAppState_Allocation, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GenesisAppState {
    return new GenesisAppState().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GenesisAppState {
    return new GenesisAppState().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GenesisAppState {
    return new GenesisAppState().fromJsonString(jsonString, options);
  }

  static equals(a: GenesisAppState | PlainMessage<GenesisAppState> | undefined, b: GenesisAppState | PlainMessage<GenesisAppState> | undefined): boolean {
    return proto3.util.equals(GenesisAppState, a, b);
  }
}

/**
 * @generated from message penumbra.chain.GenesisAppState.Allocation
 */
export class GenesisAppState_Allocation extends Message<GenesisAppState_Allocation> {
  /**
   * @generated from field: uint64 amount = 1;
   */
  amount = protoInt64.zero;

  /**
   * @generated from field: string denom = 2;
   */
  denom = "";

  /**
   * @generated from field: penumbra.crypto.Address address = 3;
   */
  address?: Address;

  constructor(data?: PartialMessage<GenesisAppState_Allocation>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "penumbra.chain.GenesisAppState.Allocation";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "amount", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 2, name: "denom", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "address", kind: "message", T: Address },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GenesisAppState_Allocation {
    return new GenesisAppState_Allocation().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GenesisAppState_Allocation {
    return new GenesisAppState_Allocation().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GenesisAppState_Allocation {
    return new GenesisAppState_Allocation().fromJsonString(jsonString, options);
  }

  static equals(a: GenesisAppState_Allocation | PlainMessage<GenesisAppState_Allocation> | undefined, b: GenesisAppState_Allocation | PlainMessage<GenesisAppState_Allocation> | undefined): boolean {
    return proto3.util.equals(GenesisAppState_Allocation, a, b);
  }
}

/**
 * @generated from message penumbra.chain.Quarantined
 */
export class Quarantined extends Message<Quarantined> {
  /**
   * @generated from field: repeated penumbra.chain.Quarantined.EpochEntry per_epoch = 1;
   */
  perEpoch: Quarantined_EpochEntry[] = [];

  constructor(data?: PartialMessage<Quarantined>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "penumbra.chain.Quarantined";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "per_epoch", kind: "message", T: Quarantined_EpochEntry, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Quarantined {
    return new Quarantined().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Quarantined {
    return new Quarantined().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Quarantined {
    return new Quarantined().fromJsonString(jsonString, options);
  }

  static equals(a: Quarantined | PlainMessage<Quarantined> | undefined, b: Quarantined | PlainMessage<Quarantined> | undefined): boolean {
    return proto3.util.equals(Quarantined, a, b);
  }
}

/**
 * @generated from message penumbra.chain.Quarantined.Unbonding
 */
export class Quarantined_Unbonding extends Message<Quarantined_Unbonding> {
  /**
   * @generated from field: repeated penumbra.chain.AnnotatedNotePayload note_payloads = 1;
   */
  notePayloads: AnnotatedNotePayload[] = [];

  /**
   * @generated from field: repeated penumbra.crypto.Nullifier nullifiers = 2;
   */
  nullifiers: Nullifier[] = [];

  constructor(data?: PartialMessage<Quarantined_Unbonding>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "penumbra.chain.Quarantined.Unbonding";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "note_payloads", kind: "message", T: AnnotatedNotePayload, repeated: true },
    { no: 2, name: "nullifiers", kind: "message", T: Nullifier, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Quarantined_Unbonding {
    return new Quarantined_Unbonding().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Quarantined_Unbonding {
    return new Quarantined_Unbonding().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Quarantined_Unbonding {
    return new Quarantined_Unbonding().fromJsonString(jsonString, options);
  }

  static equals(a: Quarantined_Unbonding | PlainMessage<Quarantined_Unbonding> | undefined, b: Quarantined_Unbonding | PlainMessage<Quarantined_Unbonding> | undefined): boolean {
    return proto3.util.equals(Quarantined_Unbonding, a, b);
  }
}

/**
 * @generated from message penumbra.chain.Quarantined.ValidatorEntry
 */
export class Quarantined_ValidatorEntry extends Message<Quarantined_ValidatorEntry> {
  /**
   * @generated from field: penumbra.crypto.IdentityKey identity_key = 1;
   */
  identityKey?: IdentityKey;

  /**
   * @generated from field: penumbra.chain.Quarantined.Unbonding unbonding = 2;
   */
  unbonding?: Quarantined_Unbonding;

  constructor(data?: PartialMessage<Quarantined_ValidatorEntry>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "penumbra.chain.Quarantined.ValidatorEntry";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "identity_key", kind: "message", T: IdentityKey },
    { no: 2, name: "unbonding", kind: "message", T: Quarantined_Unbonding },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Quarantined_ValidatorEntry {
    return new Quarantined_ValidatorEntry().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Quarantined_ValidatorEntry {
    return new Quarantined_ValidatorEntry().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Quarantined_ValidatorEntry {
    return new Quarantined_ValidatorEntry().fromJsonString(jsonString, options);
  }

  static equals(a: Quarantined_ValidatorEntry | PlainMessage<Quarantined_ValidatorEntry> | undefined, b: Quarantined_ValidatorEntry | PlainMessage<Quarantined_ValidatorEntry> | undefined): boolean {
    return proto3.util.equals(Quarantined_ValidatorEntry, a, b);
  }
}

/**
 * @generated from message penumbra.chain.Quarantined.Scheduled
 */
export class Quarantined_Scheduled extends Message<Quarantined_Scheduled> {
  /**
   * @generated from field: repeated penumbra.chain.Quarantined.ValidatorEntry per_validator = 1;
   */
  perValidator: Quarantined_ValidatorEntry[] = [];

  constructor(data?: PartialMessage<Quarantined_Scheduled>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "penumbra.chain.Quarantined.Scheduled";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "per_validator", kind: "message", T: Quarantined_ValidatorEntry, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Quarantined_Scheduled {
    return new Quarantined_Scheduled().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Quarantined_Scheduled {
    return new Quarantined_Scheduled().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Quarantined_Scheduled {
    return new Quarantined_Scheduled().fromJsonString(jsonString, options);
  }

  static equals(a: Quarantined_Scheduled | PlainMessage<Quarantined_Scheduled> | undefined, b: Quarantined_Scheduled | PlainMessage<Quarantined_Scheduled> | undefined): boolean {
    return proto3.util.equals(Quarantined_Scheduled, a, b);
  }
}

/**
 * @generated from message penumbra.chain.Quarantined.EpochEntry
 */
export class Quarantined_EpochEntry extends Message<Quarantined_EpochEntry> {
  /**
   * @generated from field: uint64 unbonding_epoch = 1;
   */
  unbondingEpoch = protoInt64.zero;

  /**
   * @generated from field: penumbra.chain.Quarantined.Scheduled scheduled = 2;
   */
  scheduled?: Quarantined_Scheduled;

  constructor(data?: PartialMessage<Quarantined_EpochEntry>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "penumbra.chain.Quarantined.EpochEntry";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "unbonding_epoch", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 2, name: "scheduled", kind: "message", T: Quarantined_Scheduled },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Quarantined_EpochEntry {
    return new Quarantined_EpochEntry().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Quarantined_EpochEntry {
    return new Quarantined_EpochEntry().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Quarantined_EpochEntry {
    return new Quarantined_EpochEntry().fromJsonString(jsonString, options);
  }

  static equals(a: Quarantined_EpochEntry | PlainMessage<Quarantined_EpochEntry> | undefined, b: Quarantined_EpochEntry | PlainMessage<Quarantined_EpochEntry> | undefined): boolean {
    return proto3.util.equals(Quarantined_EpochEntry, a, b);
  }
}

/**
 * @generated from message penumbra.chain.Slashed
 */
export class Slashed extends Message<Slashed> {
  /**
   * @generated from field: repeated penumbra.crypto.IdentityKey validators = 1;
   */
  validators: IdentityKey[] = [];

  constructor(data?: PartialMessage<Slashed>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "penumbra.chain.Slashed";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "validators", kind: "message", T: IdentityKey, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Slashed {
    return new Slashed().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Slashed {
    return new Slashed().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Slashed {
    return new Slashed().fromJsonString(jsonString, options);
  }

  static equals(a: Slashed | PlainMessage<Slashed> | undefined, b: Slashed | PlainMessage<Slashed> | undefined): boolean {
    return proto3.util.equals(Slashed, a, b);
  }
}

