// @generated by protoc-gen-es v0.1.1 with parameter "target=ts"
// @generated from file transaction.proto (package penumbra.transaction, syntax proto3)
/* eslint-disable */
/* @ts-nocheck */

import type {BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage} from "@bufbuild/protobuf";
import {Message, proto3, protoInt64} from "@bufbuild/protobuf";
import {Address, Clue, Fee, GovernanceKey, IdentityKey, MerkleRoot, Note, NoteCommitmentProof, NotePayload, SpendAuthSignature, Value, ValueCommitment} from "./crypto_pb.js";
import {Delegate, Undelegate, ValidatorDefinition} from "./stake_pb.js";
import {BatchSwapOutputData, PositionClose, PositionOpen, PositionRewardClaim, PositionWithdraw, Swap, SwapClaim, SwapPlaintext} from "./dex_pb.js";
import {IBCAction, ICS20Withdrawal} from "./ibc_pb.js";
import {Vote} from "./governance_pb.js";

/**
 * An authorization hash for a Penumbra transaction.
 *
 * @generated from message penumbra.transaction.AuthHash
 */
export class AuthHash extends Message<AuthHash> {
  /**
   * @generated from field: bytes inner = 1;
   */
  inner = new Uint8Array(0);

  constructor(data?: PartialMessage<AuthHash>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "penumbra.transaction.AuthHash";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "inner", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AuthHash {
    return new AuthHash().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AuthHash {
    return new AuthHash().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AuthHash {
    return new AuthHash().fromJsonString(jsonString, options);
  }

  static equals(a: AuthHash | PlainMessage<AuthHash> | undefined, b: AuthHash | PlainMessage<AuthHash> | undefined): boolean {
    return proto3.util.equals(AuthHash, a, b);
  }
}

/**
 * A Penumbra transaction.
 *
 * @generated from message penumbra.transaction.Transaction
 */
export class Transaction extends Message<Transaction> {
  /**
   * @generated from field: penumbra.transaction.TransactionBody body = 1;
   */
  body?: TransactionBody;

  /**
   * The binding signature is stored separately from the transaction body that it signs.
   *
   * @generated from field: bytes binding_sig = 2;
   */
  bindingSig = new Uint8Array(0);

  /**
   * The root of some previous state of the note commitment tree, used as an anchor for all
   * ZK state transition proofs.
   *
   * @generated from field: penumbra.crypto.MerkleRoot anchor = 3;
   */
  anchor?: MerkleRoot;

  constructor(data?: PartialMessage<Transaction>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "penumbra.transaction.Transaction";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "body", kind: "message", T: TransactionBody },
    { no: 2, name: "binding_sig", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 3, name: "anchor", kind: "message", T: MerkleRoot },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Transaction {
    return new Transaction().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Transaction {
    return new Transaction().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Transaction {
    return new Transaction().fromJsonString(jsonString, options);
  }

  static equals(a: Transaction | PlainMessage<Transaction> | undefined, b: Transaction | PlainMessage<Transaction> | undefined): boolean {
    return proto3.util.equals(Transaction, a, b);
  }
}

/**
 * The body of a transaction.
 *
 * @generated from message penumbra.transaction.TransactionBody
 */
export class TransactionBody extends Message<TransactionBody> {
  /**
   * A list of actions (state changes) performed by this transaction.
   *
   * @generated from field: repeated penumbra.transaction.Action actions = 1;
   */
  actions: Action[] = [];

  /**
   * The maximum height that this transaction can be included in the chain.
   *
   * If zero, there is no maximum.
   *
   * @generated from field: uint64 expiry_height = 2;
   */
  expiryHeight = protoInt64.zero;

  /**
   * The chain this transaction is intended for.  Including this prevents
   * replaying a transaction on one chain onto a different chain.
   *
   * @generated from field: string chain_id = 3;
   */
  chainId = "";

  /**
   * The transaction fee.
   *
   * @generated from field: penumbra.crypto.Fee fee = 4;
   */
  fee?: Fee;

  /**
   * A list of clues for use with Fuzzy Message Detection.
   *
   * @generated from field: repeated penumbra.crypto.Clue fmd_clues = 5;
   */
  fmdClues: Clue[] = [];

  /**
   * An optional encrypted memo. It will only be populated if there are
   * outputs in the actions of this transaction. 528 bytes.
   *
   * @generated from field: optional bytes encrypted_memo = 6;
   */
  encryptedMemo?: Uint8Array;

  constructor(data?: PartialMessage<TransactionBody>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "penumbra.transaction.TransactionBody";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "actions", kind: "message", T: Action, repeated: true },
    { no: 2, name: "expiry_height", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 3, name: "chain_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "fee", kind: "message", T: Fee },
    { no: 5, name: "fmd_clues", kind: "message", T: Clue, repeated: true },
    { no: 6, name: "encrypted_memo", kind: "scalar", T: 12 /* ScalarType.BYTES */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TransactionBody {
    return new TransactionBody().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TransactionBody {
    return new TransactionBody().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TransactionBody {
    return new TransactionBody().fromJsonString(jsonString, options);
  }

  static equals(a: TransactionBody | PlainMessage<TransactionBody> | undefined, b: TransactionBody | PlainMessage<TransactionBody> | undefined): boolean {
    return proto3.util.equals(TransactionBody, a, b);
  }
}

/**
 * A state change performed by a transaction.
 *
 * @generated from message penumbra.transaction.Action
 */
export class Action extends Message<Action> {
  /**
   * @generated from oneof penumbra.transaction.Action.action
   */
  action: {
    /**
     * @generated from field: penumbra.transaction.Spend spend = 1;
     */
    value: Spend;
    case: "spend";
  } | {
    /**
     * @generated from field: penumbra.transaction.Output output = 2;
     */
    value: Output;
    case: "output";
  } | {
    /**
     * @generated from field: penumbra.stake.Delegate delegate = 3;
     */
    value: Delegate;
    case: "delegate";
  } | {
    /**
     * @generated from field: penumbra.stake.Undelegate undelegate = 4;
     */
    value: Undelegate;
    case: "undelegate";
  } | {
    /**
     * @generated from field: penumbra.dex.Swap swap = 5;
     */
    value: Swap;
    case: "swap";
  } | {
    /**
     * @generated from field: penumbra.dex.SwapClaim swap_claim = 6;
     */
    value: SwapClaim;
    case: "swapClaim";
  } | {
    /**
     * @generated from field: penumbra.stake.ValidatorDefinition validator_definition = 16;
     */
    value: ValidatorDefinition;
    case: "validatorDefinition";
  } | {
    /**
     * @generated from field: penumbra.ibc.IBCAction ibc_action = 17;
     */
    value: IBCAction;
    case: "ibcAction";
  } | {
    /**
     * Governance:
     *
     * @generated from field: penumbra.transaction.ProposalSubmit proposal_submit = 18;
     */
    value: ProposalSubmit;
    case: "proposalSubmit";
  } | {
    /**
     * @generated from field: penumbra.transaction.ProposalWithdraw proposal_withdraw = 19;
     */
    value: ProposalWithdraw;
    case: "proposalWithdraw";
  } | {
    /**
     * DelegatorVote delegator_vote = 21;
     *
     * @generated from field: penumbra.transaction.ValidatorVote validator_vote = 20;
     */
    value: ValidatorVote;
    case: "validatorVote";
  } | {
    /**
     * @generated from field: penumbra.dex.PositionOpen position_open = 30;
     */
    value: PositionOpen;
    case: "positionOpen";
  } | {
    /**
     * @generated from field: penumbra.dex.PositionClose position_close = 31;
     */
    value: PositionClose;
    case: "positionClose";
  } | {
    /**
     * @generated from field: penumbra.dex.PositionWithdraw position_withdraw = 32;
     */
    value: PositionWithdraw;
    case: "positionWithdraw";
  } | {
    /**
     * @generated from field: penumbra.dex.PositionRewardClaim position_reward_claim = 34;
     */
    value: PositionRewardClaim;
    case: "positionRewardClaim";
  } | {
    /**
     * @generated from field: penumbra.ibc.ICS20Withdrawal ics20_withdrawal = 200;
     */
    value: ICS20Withdrawal;
    case: "ics20Withdrawal";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<Action>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "penumbra.transaction.Action";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "spend", kind: "message", T: Spend, oneof: "action" },
    { no: 2, name: "output", kind: "message", T: Output, oneof: "action" },
    { no: 3, name: "delegate", kind: "message", T: Delegate, oneof: "action" },
    { no: 4, name: "undelegate", kind: "message", T: Undelegate, oneof: "action" },
    { no: 5, name: "swap", kind: "message", T: Swap, oneof: "action" },
    { no: 6, name: "swap_claim", kind: "message", T: SwapClaim, oneof: "action" },
    { no: 16, name: "validator_definition", kind: "message", T: ValidatorDefinition, oneof: "action" },
    { no: 17, name: "ibc_action", kind: "message", T: IBCAction, oneof: "action" },
    { no: 18, name: "proposal_submit", kind: "message", T: ProposalSubmit, oneof: "action" },
    { no: 19, name: "proposal_withdraw", kind: "message", T: ProposalWithdraw, oneof: "action" },
    { no: 20, name: "validator_vote", kind: "message", T: ValidatorVote, oneof: "action" },
    { no: 30, name: "position_open", kind: "message", T: PositionOpen, oneof: "action" },
    { no: 31, name: "position_close", kind: "message", T: PositionClose, oneof: "action" },
    { no: 32, name: "position_withdraw", kind: "message", T: PositionWithdraw, oneof: "action" },
    { no: 34, name: "position_reward_claim", kind: "message", T: PositionRewardClaim, oneof: "action" },
    { no: 200, name: "ics20_withdrawal", kind: "message", T: ICS20Withdrawal, oneof: "action" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Action {
    return new Action().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Action {
    return new Action().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Action {
    return new Action().fromJsonString(jsonString, options);
  }

  static equals(a: Action | PlainMessage<Action> | undefined, b: Action | PlainMessage<Action> | undefined): boolean {
    return proto3.util.equals(Action, a, b);
  }
}

/**
 * Spends a shielded note.
 *
 * @generated from message penumbra.transaction.Spend
 */
export class Spend extends Message<Spend> {
  /**
   * The authorizing data for the spend, which is included in the authorization hash used for signing.
   *
   * @generated from field: penumbra.transaction.SpendBody body = 1;
   */
  body?: SpendBody;

  /**
   * The spend authorization signature is effecting data.
   *
   * @generated from field: penumbra.crypto.SpendAuthSignature auth_sig = 2;
   */
  authSig?: SpendAuthSignature;

  /**
   * The spend proof is effecting data.
   *
   * @generated from field: bytes proof = 3;
   */
  proof = new Uint8Array(0);

  constructor(data?: PartialMessage<Spend>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "penumbra.transaction.Spend";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "body", kind: "message", T: SpendBody },
    { no: 2, name: "auth_sig", kind: "message", T: SpendAuthSignature },
    { no: 3, name: "proof", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Spend {
    return new Spend().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Spend {
    return new Spend().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Spend {
    return new Spend().fromJsonString(jsonString, options);
  }

  static equals(a: Spend | PlainMessage<Spend> | undefined, b: Spend | PlainMessage<Spend> | undefined): boolean {
    return proto3.util.equals(Spend, a, b);
  }
}

/**
 * The body of a spend description, containing only the "authorizing" data
 * included in the authorization hash used for signing, and not the "effecting"
 * data which is bound to the authorizing data by some other means.
 *
 * @generated from message penumbra.transaction.SpendBody
 */
export class SpendBody extends Message<SpendBody> {
  /**
   * A commitment to the value of the input note.
   *
   * @generated from field: penumbra.crypto.ValueCommitment value_commitment = 1;
   */
  valueCommitment?: ValueCommitment;

  /**
   * The nullifier of the input note.
   *
   * @generated from field: bytes nullifier = 3;
   */
  nullifier = new Uint8Array(0);

  /**
   * The randomized validating key for the spend authorization signature.
   *
   * @generated from field: bytes rk = 4;
   */
  rk = new Uint8Array(0);

  constructor(data?: PartialMessage<SpendBody>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "penumbra.transaction.SpendBody";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "value_commitment", kind: "message", T: ValueCommitment },
    { no: 3, name: "nullifier", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 4, name: "rk", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SpendBody {
    return new SpendBody().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SpendBody {
    return new SpendBody().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SpendBody {
    return new SpendBody().fromJsonString(jsonString, options);
  }

  static equals(a: SpendBody | PlainMessage<SpendBody> | undefined, b: SpendBody | PlainMessage<SpendBody> | undefined): boolean {
    return proto3.util.equals(SpendBody, a, b);
  }
}

/**
 * Creates a new shielded note.
 *
 * @generated from message penumbra.transaction.Output
 */
export class Output extends Message<Output> {
  /**
   * The authorizing data for the output.
   *
   * @generated from field: penumbra.transaction.OutputBody body = 1;
   */
  body?: OutputBody;

  /**
   * The output proof is effecting data.
   *
   * @generated from field: bytes proof = 2;
   */
  proof = new Uint8Array(0);

  constructor(data?: PartialMessage<Output>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "penumbra.transaction.Output";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "body", kind: "message", T: OutputBody },
    { no: 2, name: "proof", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Output {
    return new Output().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Output {
    return new Output().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Output {
    return new Output().fromJsonString(jsonString, options);
  }

  static equals(a: Output | PlainMessage<Output> | undefined, b: Output | PlainMessage<Output> | undefined): boolean {
    return proto3.util.equals(Output, a, b);
  }
}

/**
 * The body of an output description, containing only the "authorizing" data
 * included in the authorization hash used for signing, and not the "effecting"
 * data which is bound to the authorizing data by some other means.
 *
 * @generated from message penumbra.transaction.OutputBody
 */
export class OutputBody extends Message<OutputBody> {
  /**
   * The minimal data required to scan and process the new output note.
   *
   * @generated from field: penumbra.crypto.NotePayload note_payload = 1;
   */
  notePayload?: NotePayload;

  /**
   * A commitment to the value of the output note. 32 bytes.
   *
   * @generated from field: penumbra.crypto.ValueCommitment value_commitment = 2;
   */
  valueCommitment?: ValueCommitment;

  /**
   * An encrypted key for decrypting the memo.
   *
   * @generated from field: bytes wrapped_memo_key = 3;
   */
  wrappedMemoKey = new Uint8Array(0);

  /**
   * The key material used for note encryption, wrapped in encryption to the
   * sender's outgoing viewing key. 80 bytes.
   *
   * @generated from field: bytes ovk_wrapped_key = 4;
   */
  ovkWrappedKey = new Uint8Array(0);

  constructor(data?: PartialMessage<OutputBody>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "penumbra.transaction.OutputBody";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "note_payload", kind: "message", T: NotePayload },
    { no: 2, name: "value_commitment", kind: "message", T: ValueCommitment },
    { no: 3, name: "wrapped_memo_key", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 4, name: "ovk_wrapped_key", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): OutputBody {
    return new OutputBody().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): OutputBody {
    return new OutputBody().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): OutputBody {
    return new OutputBody().fromJsonString(jsonString, options);
  }

  static equals(a: OutputBody | PlainMessage<OutputBody> | undefined, b: OutputBody | PlainMessage<OutputBody> | undefined): boolean {
    return proto3.util.equals(OutputBody, a, b);
  }
}

/**
 * @generated from message penumbra.transaction.ProposalSubmit
 */
export class ProposalSubmit extends Message<ProposalSubmit> {
  /**
   * The proposal to be submitted.
   *
   * @generated from field: penumbra.transaction.Proposal proposal = 1;
   */
  proposal?: Proposal;

  /**
   * The ephemeral transparent refund address for the refund of the proposal deposit.
   *
   * @generated from field: penumbra.crypto.Address deposit_refund_address = 2;
   */
  depositRefundAddress?: Address;

  /**
   * The amount of the proposal deposit.
   *
   * @generated from field: uint64 deposit_amount = 3;
   */
  depositAmount = protoInt64.zero;

  /**
   * The randomized proposer key (a randomization of the proposer's spend verification key).
   *
   * @generated from field: bytes rk = 4;
   */
  rk = new Uint8Array(0);

  constructor(data?: PartialMessage<ProposalSubmit>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "penumbra.transaction.ProposalSubmit";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "proposal", kind: "message", T: Proposal },
    { no: 2, name: "deposit_refund_address", kind: "message", T: Address },
    { no: 3, name: "deposit_amount", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 4, name: "rk", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ProposalSubmit {
    return new ProposalSubmit().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ProposalSubmit {
    return new ProposalSubmit().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ProposalSubmit {
    return new ProposalSubmit().fromJsonString(jsonString, options);
  }

  static equals(a: ProposalSubmit | PlainMessage<ProposalSubmit> | undefined, b: ProposalSubmit | PlainMessage<ProposalSubmit> | undefined): boolean {
    return proto3.util.equals(ProposalSubmit, a, b);
  }
}

/**
 * @generated from message penumbra.transaction.ProposalWithdraw
 */
export class ProposalWithdraw extends Message<ProposalWithdraw> {
  /**
   * The body of the proposal withdraw message.
   *
   * @generated from field: penumbra.transaction.ProposalWithdrawBody body = 1;
   */
  body?: ProposalWithdrawBody;

  /**
   * The signature with the randomized proposer key of the withdrawal.
   *
   * @generated from field: penumbra.crypto.SpendAuthSignature auth_sig = 2;
   */
  authSig?: SpendAuthSignature;

  constructor(data?: PartialMessage<ProposalWithdraw>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "penumbra.transaction.ProposalWithdraw";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "body", kind: "message", T: ProposalWithdrawBody },
    { no: 2, name: "auth_sig", kind: "message", T: SpendAuthSignature },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ProposalWithdraw {
    return new ProposalWithdraw().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ProposalWithdraw {
    return new ProposalWithdraw().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ProposalWithdraw {
    return new ProposalWithdraw().fromJsonString(jsonString, options);
  }

  static equals(a: ProposalWithdraw | PlainMessage<ProposalWithdraw> | undefined, b: ProposalWithdraw | PlainMessage<ProposalWithdraw> | undefined): boolean {
    return proto3.util.equals(ProposalWithdraw, a, b);
  }
}

/**
 * @generated from message penumbra.transaction.ProposalWithdrawBody
 */
export class ProposalWithdrawBody extends Message<ProposalWithdrawBody> {
  /**
   * The proposal to be withdrawn.
   *
   * @generated from field: uint64 proposal = 1;
   */
  proposal = protoInt64.zero;

  /**
   * The reason for the proposal being withdrawn.
   *
   * @generated from field: string reason = 2;
   */
  reason = "";

  constructor(data?: PartialMessage<ProposalWithdrawBody>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "penumbra.transaction.ProposalWithdrawBody";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "proposal", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 2, name: "reason", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ProposalWithdrawBody {
    return new ProposalWithdrawBody().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ProposalWithdrawBody {
    return new ProposalWithdrawBody().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ProposalWithdrawBody {
    return new ProposalWithdrawBody().fromJsonString(jsonString, options);
  }

  static equals(a: ProposalWithdrawBody | PlainMessage<ProposalWithdrawBody> | undefined, b: ProposalWithdrawBody | PlainMessage<ProposalWithdrawBody> | undefined): boolean {
    return proto3.util.equals(ProposalWithdrawBody, a, b);
  }
}

/**
 * @generated from message penumbra.transaction.ValidatorVote
 */
export class ValidatorVote extends Message<ValidatorVote> {
  /**
   * The authorizing data for the vote.
   *
   * @generated from field: penumbra.transaction.ValidatorVoteBody body = 1;
   */
  body?: ValidatorVoteBody;

  /**
   * The vote authorization signature is effecting data.
   *
   * @generated from field: penumbra.crypto.SpendAuthSignature auth_sig = 2;
   */
  authSig?: SpendAuthSignature;

  constructor(data?: PartialMessage<ValidatorVote>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "penumbra.transaction.ValidatorVote";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "body", kind: "message", T: ValidatorVoteBody },
    { no: 2, name: "auth_sig", kind: "message", T: SpendAuthSignature },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ValidatorVote {
    return new ValidatorVote().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ValidatorVote {
    return new ValidatorVote().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ValidatorVote {
    return new ValidatorVote().fromJsonString(jsonString, options);
  }

  static equals(a: ValidatorVote | PlainMessage<ValidatorVote> | undefined, b: ValidatorVote | PlainMessage<ValidatorVote> | undefined): boolean {
    return proto3.util.equals(ValidatorVote, a, b);
  }
}

/**
 * @generated from message penumbra.transaction.ValidatorVoteBody
 */
export class ValidatorVoteBody extends Message<ValidatorVoteBody> {
  /**
   * The proposal being voted on.
   *
   * @generated from field: uint64 proposal = 1;
   */
  proposal = protoInt64.zero;

  /**
   * The vote.
   *
   * @generated from field: penumbra.governance.Vote vote = 2;
   */
  vote?: Vote;

  /**
   * The validator identity.
   *
   * @generated from field: penumbra.crypto.IdentityKey identity_key = 3;
   */
  identityKey?: IdentityKey;

  /**
   * The validator governance key.
   *
   * @generated from field: penumbra.crypto.GovernanceKey governance_key = 4;
   */
  governanceKey?: GovernanceKey;

  constructor(data?: PartialMessage<ValidatorVoteBody>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "penumbra.transaction.ValidatorVoteBody";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "proposal", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 2, name: "vote", kind: "message", T: Vote },
    { no: 3, name: "identity_key", kind: "message", T: IdentityKey },
    { no: 4, name: "governance_key", kind: "message", T: GovernanceKey },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ValidatorVoteBody {
    return new ValidatorVoteBody().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ValidatorVoteBody {
    return new ValidatorVoteBody().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ValidatorVoteBody {
    return new ValidatorVoteBody().fromJsonString(jsonString, options);
  }

  static equals(a: ValidatorVoteBody | PlainMessage<ValidatorVoteBody> | undefined, b: ValidatorVoteBody | PlainMessage<ValidatorVoteBody> | undefined): boolean {
    return proto3.util.equals(ValidatorVoteBody, a, b);
  }
}

/**
 * @generated from message penumbra.transaction.DelegatorVote
 */
export class DelegatorVote extends Message<DelegatorVote> {
  /**
   * The authorizing data for the vote, which is included in the authorization hash used for signing.
   *
   * @generated from field: penumbra.transaction.DelegatorVoteBody body = 1;
   */
  body?: DelegatorVoteBody;

  /**
   * The vote authorization signature is effecting data.
   *
   * @generated from field: penumbra.crypto.SpendAuthSignature auth_sig = 2;
   */
  authSig?: SpendAuthSignature;

  /**
   * The vote proof is effecting data.
   *
   * @generated from field: bytes proof = 3;
   */
  proof = new Uint8Array(0);

  constructor(data?: PartialMessage<DelegatorVote>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "penumbra.transaction.DelegatorVote";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "body", kind: "message", T: DelegatorVoteBody },
    { no: 2, name: "auth_sig", kind: "message", T: SpendAuthSignature },
    { no: 3, name: "proof", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DelegatorVote {
    return new DelegatorVote().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DelegatorVote {
    return new DelegatorVote().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DelegatorVote {
    return new DelegatorVote().fromJsonString(jsonString, options);
  }

  static equals(a: DelegatorVote | PlainMessage<DelegatorVote> | undefined, b: DelegatorVote | PlainMessage<DelegatorVote> | undefined): boolean {
    return proto3.util.equals(DelegatorVote, a, b);
  }
}

/**
 * @generated from message penumbra.transaction.DelegatorVoteBody
 */
export class DelegatorVoteBody extends Message<DelegatorVoteBody> {
  /**
   * The proposal being voted on.
   *
   * @generated from field: uint64 proposal = 1;
   */
  proposal = protoInt64.zero;

  /**
   * The nullifier of the input note.
   *
   * @generated from field: bytes nullifier = 3;
   */
  nullifier = new Uint8Array(0);

  /**
   * The randomized validating key for the spend authorization signature.
   *
   * @generated from field: bytes rk = 4;
   */
  rk = new Uint8Array(0);

  /**
   * A commitment to the value voted for "yes".
   *
   * A rational voter will place all their voting weight on one vote.
   *
   * @generated from field: penumbra.crypto.ValueCommitment yes_value_commitment = 5;
   */
  yesValueCommitment?: ValueCommitment;

  /**
   * A commitment to the value voted for "no".
   *
   * A rational voter will place all their voting weight on one vote.
   *
   * @generated from field: penumbra.crypto.ValueCommitment no_value_commitment = 6;
   */
  noValueCommitment?: ValueCommitment;

  /**
   * A commitment to the value voted for "abstain".
   *
   * A rational voter will place all their voting weight on one vote.
   *
   * @generated from field: penumbra.crypto.ValueCommitment abstain_value_commitment = 7;
   */
  abstainValueCommitment?: ValueCommitment;

  /**
   * A commitment to the value voted for "no with veto".
   *
   * A rational voter will place all their voting weight on one vote.
   *
   * @generated from field: penumbra.crypto.ValueCommitment no_with_veto_value_commitment = 8;
   */
  noWithVetoValueCommitment?: ValueCommitment;

  constructor(data?: PartialMessage<DelegatorVoteBody>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "penumbra.transaction.DelegatorVoteBody";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "proposal", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 3, name: "nullifier", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 4, name: "rk", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 5, name: "yes_value_commitment", kind: "message", T: ValueCommitment },
    { no: 6, name: "no_value_commitment", kind: "message", T: ValueCommitment },
    { no: 7, name: "abstain_value_commitment", kind: "message", T: ValueCommitment },
    { no: 8, name: "no_with_veto_value_commitment", kind: "message", T: ValueCommitment },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DelegatorVoteBody {
    return new DelegatorVoteBody().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DelegatorVoteBody {
    return new DelegatorVoteBody().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DelegatorVoteBody {
    return new DelegatorVoteBody().fromJsonString(jsonString, options);
  }

  static equals(a: DelegatorVoteBody | PlainMessage<DelegatorVoteBody> | undefined, b: DelegatorVoteBody | PlainMessage<DelegatorVoteBody> | undefined): boolean {
    return proto3.util.equals(DelegatorVoteBody, a, b);
  }
}

/**
 * The data required to authorize a transaction plan.
 *
 * @generated from message penumbra.transaction.AuthorizationData
 */
export class AuthorizationData extends Message<AuthorizationData> {
  /**
   * The computed auth hash for the approved transaction plan.
   *
   * @generated from field: penumbra.transaction.AuthHash auth_hash = 1;
   */
  authHash?: AuthHash;

  /**
   * The required spend authorizations, returned in the same order as the
   * Spend actions in the original request.
   *
   * @generated from field: repeated penumbra.crypto.SpendAuthSignature spend_auths = 2;
   */
  spendAuths: SpendAuthSignature[] = [];

  /**
   * The required withdraw proposal authorizations, returned in the same order as the
   * ProposalWithdraw actions in the original request.
   *
   * @generated from field: repeated penumbra.crypto.SpendAuthSignature withdraw_proposal_auths = 3;
   */
  withdrawProposalAuths: SpendAuthSignature[] = [];

  constructor(data?: PartialMessage<AuthorizationData>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "penumbra.transaction.AuthorizationData";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "auth_hash", kind: "message", T: AuthHash },
    { no: 2, name: "spend_auths", kind: "message", T: SpendAuthSignature, repeated: true },
    { no: 3, name: "withdraw_proposal_auths", kind: "message", T: SpendAuthSignature, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AuthorizationData {
    return new AuthorizationData().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AuthorizationData {
    return new AuthorizationData().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AuthorizationData {
    return new AuthorizationData().fromJsonString(jsonString, options);
  }

  static equals(a: AuthorizationData | PlainMessage<AuthorizationData> | undefined, b: AuthorizationData | PlainMessage<AuthorizationData> | undefined): boolean {
    return proto3.util.equals(AuthorizationData, a, b);
  }
}

/**
 * The data required for proving when building a transaction from a plan.
 *
 * @generated from message penumbra.transaction.WitnessData
 */
export class WitnessData extends Message<WitnessData> {
  /**
   * The anchor for the state transition proofs.
   *
   * @generated from field: penumbra.crypto.MerkleRoot anchor = 1;
   */
  anchor?: MerkleRoot;

  /**
   * The auth paths for the notes the transaction spends, in the
   * same order as the spends in the transaction plan.
   *
   * @generated from field: repeated penumbra.crypto.NoteCommitmentProof note_commitment_proofs = 2;
   */
  noteCommitmentProofs: NoteCommitmentProof[] = [];

  constructor(data?: PartialMessage<WitnessData>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "penumbra.transaction.WitnessData";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "anchor", kind: "message", T: MerkleRoot },
    { no: 2, name: "note_commitment_proofs", kind: "message", T: NoteCommitmentProof, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): WitnessData {
    return new WitnessData().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): WitnessData {
    return new WitnessData().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): WitnessData {
    return new WitnessData().fromJsonString(jsonString, options);
  }

  static equals(a: WitnessData | PlainMessage<WitnessData> | undefined, b: WitnessData | PlainMessage<WitnessData> | undefined): boolean {
    return proto3.util.equals(WitnessData, a, b);
  }
}

/**
 * Describes a planned transaction.
 *
 * @generated from message penumbra.transaction.TransactionPlan
 */
export class TransactionPlan extends Message<TransactionPlan> {
  /**
   * @generated from field: repeated penumbra.transaction.ActionPlan actions = 1;
   */
  actions: ActionPlan[] = [];

  /**
   * @generated from field: uint64 expiry_height = 2;
   */
  expiryHeight = protoInt64.zero;

  /**
   * @generated from field: string chain_id = 3;
   */
  chainId = "";

  /**
   * @generated from field: penumbra.crypto.Fee fee = 4;
   */
  fee?: Fee;

  /**
   * @generated from field: repeated penumbra.transaction.CluePlan clue_plans = 5;
   */
  cluePlans: CluePlan[] = [];

  /**
   * @generated from field: penumbra.transaction.MemoPlan memo_plan = 6;
   */
  memoPlan?: MemoPlan;

  constructor(data?: PartialMessage<TransactionPlan>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "penumbra.transaction.TransactionPlan";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "actions", kind: "message", T: ActionPlan, repeated: true },
    { no: 2, name: "expiry_height", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 3, name: "chain_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "fee", kind: "message", T: Fee },
    { no: 5, name: "clue_plans", kind: "message", T: CluePlan, repeated: true },
    { no: 6, name: "memo_plan", kind: "message", T: MemoPlan },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TransactionPlan {
    return new TransactionPlan().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TransactionPlan {
    return new TransactionPlan().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TransactionPlan {
    return new TransactionPlan().fromJsonString(jsonString, options);
  }

  static equals(a: TransactionPlan | PlainMessage<TransactionPlan> | undefined, b: TransactionPlan | PlainMessage<TransactionPlan> | undefined): boolean {
    return proto3.util.equals(TransactionPlan, a, b);
  }
}

/**
 * Describes a planned transaction action.
 *
 * Some transaction Actions don't have any private data and are treated as being plans
 * themselves.
 *
 * @generated from message penumbra.transaction.ActionPlan
 */
export class ActionPlan extends Message<ActionPlan> {
  /**
   * @generated from oneof penumbra.transaction.ActionPlan.action
   */
  action: {
    /**
     * @generated from field: penumbra.transaction.SpendPlan spend = 1;
     */
    value: SpendPlan;
    case: "spend";
  } | {
    /**
     * @generated from field: penumbra.transaction.OutputPlan output = 2;
     */
    value: OutputPlan;
    case: "output";
  } | {
    /**
     * We don't need any extra information (yet) to understand delegations,
     * because we don't yet use flow encryption.
     *
     * @generated from field: penumbra.stake.Delegate delegate = 3;
     */
    value: Delegate;
    case: "delegate";
  } | {
    /**
     * We don't need any extra information (yet) to understand undelegations,
     * because we don't yet use flow encryption.
     *
     * @generated from field: penumbra.stake.Undelegate undelegate = 4;
     */
    value: Undelegate;
    case: "undelegate";
  } | {
    /**
     * This is just a message relayed to the chain.
     *
     * @generated from field: penumbra.stake.ValidatorDefinition validator_definition = 16;
     */
    value: ValidatorDefinition;
    case: "validatorDefinition";
  } | {
    /**
     * This is just a message relayed to the chain.
     *
     * @generated from field: penumbra.ibc.IBCAction ibc_action = 17;
     */
    value: IBCAction;
    case: "ibcAction";
  } | {
    /**
     * Governance:
     *
     * @generated from field: penumbra.transaction.ProposalSubmit proposal_submit = 18;
     */
    value: ProposalSubmit;
    case: "proposalSubmit";
  } | {
    /**
     * @generated from field: penumbra.transaction.ProposalWithdrawPlan proposal_withdraw = 19;
     */
    value: ProposalWithdrawPlan;
    case: "proposalWithdraw";
  } | {
    /**
     * @generated from field: penumbra.transaction.ValidatorVote validator_vote = 20;
     */
    value: ValidatorVote;
    case: "validatorVote";
  } | {
    /**
     * @generated from field: penumbra.transaction.DelegatorVotePlan delegator_vote = 21;
     */
    value: DelegatorVotePlan;
    case: "delegatorVote";
  } | {
    /**
     * @generated from field: penumbra.dex.PositionOpen position_open = 30;
     */
    value: PositionOpen;
    case: "positionOpen";
  } | {
    /**
     * @generated from field: penumbra.dex.PositionClose position_close = 31;
     */
    value: PositionClose;
    case: "positionClose";
  } | {
    /**
     * @generated from field: penumbra.dex.PositionWithdraw position_withdraw = 32;
     */
    value: PositionWithdraw;
    case: "positionWithdraw";
  } | {
    /**
     * @generated from field: penumbra.dex.PositionRewardClaim position_reward_claim = 34;
     */
    value: PositionRewardClaim;
    case: "positionRewardClaim";
  } | {
    /**
     * @generated from field: penumbra.transaction.SwapPlan swap = 40;
     */
    value: SwapPlan;
    case: "swap";
  } | {
    /**
     * @generated from field: penumbra.transaction.SwapClaimPlan swap_claim = 41;
     */
    value: SwapClaimPlan;
    case: "swapClaim";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<ActionPlan>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "penumbra.transaction.ActionPlan";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "spend", kind: "message", T: SpendPlan, oneof: "action" },
    { no: 2, name: "output", kind: "message", T: OutputPlan, oneof: "action" },
    { no: 3, name: "delegate", kind: "message", T: Delegate, oneof: "action" },
    { no: 4, name: "undelegate", kind: "message", T: Undelegate, oneof: "action" },
    { no: 16, name: "validator_definition", kind: "message", T: ValidatorDefinition, oneof: "action" },
    { no: 17, name: "ibc_action", kind: "message", T: IBCAction, oneof: "action" },
    { no: 18, name: "proposal_submit", kind: "message", T: ProposalSubmit, oneof: "action" },
    { no: 19, name: "proposal_withdraw", kind: "message", T: ProposalWithdrawPlan, oneof: "action" },
    { no: 20, name: "validator_vote", kind: "message", T: ValidatorVote, oneof: "action" },
    { no: 21, name: "delegator_vote", kind: "message", T: DelegatorVotePlan, oneof: "action" },
    { no: 30, name: "position_open", kind: "message", T: PositionOpen, oneof: "action" },
    { no: 31, name: "position_close", kind: "message", T: PositionClose, oneof: "action" },
    { no: 32, name: "position_withdraw", kind: "message", T: PositionWithdraw, oneof: "action" },
    { no: 34, name: "position_reward_claim", kind: "message", T: PositionRewardClaim, oneof: "action" },
    { no: 40, name: "swap", kind: "message", T: SwapPlan, oneof: "action" },
    { no: 41, name: "swap_claim", kind: "message", T: SwapClaimPlan, oneof: "action" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ActionPlan {
    return new ActionPlan().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ActionPlan {
    return new ActionPlan().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ActionPlan {
    return new ActionPlan().fromJsonString(jsonString, options);
  }

  static equals(a: ActionPlan | PlainMessage<ActionPlan> | undefined, b: ActionPlan | PlainMessage<ActionPlan> | undefined): boolean {
    return proto3.util.equals(ActionPlan, a, b);
  }
}

/**
 * Describes a plan for forming a `Clue`.
 *
 * @generated from message penumbra.transaction.CluePlan
 */
export class CluePlan extends Message<CluePlan> {
  /**
   * The address.
   *
   * @generated from field: penumbra.crypto.Address address = 1;
   */
  address?: Address;

  /**
   * The random seed to use for the clue plan.
   *
   * @generated from field: bytes rseed = 2;
   */
  rseed = new Uint8Array(0);

  /**
   * The bits of precision.
   *
   * @generated from field: uint64 precision_bits = 3;
   */
  precisionBits = protoInt64.zero;

  constructor(data?: PartialMessage<CluePlan>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "penumbra.transaction.CluePlan";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "address", kind: "message", T: Address },
    { no: 2, name: "rseed", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 3, name: "precision_bits", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CluePlan {
    return new CluePlan().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CluePlan {
    return new CluePlan().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CluePlan {
    return new CluePlan().fromJsonString(jsonString, options);
  }

  static equals(a: CluePlan | PlainMessage<CluePlan> | undefined, b: CluePlan | PlainMessage<CluePlan> | undefined): boolean {
    return proto3.util.equals(CluePlan, a, b);
  }
}

/**
 * Describes a plan for forming a `Memo`.
 *
 * @generated from message penumbra.transaction.MemoPlan
 */
export class MemoPlan extends Message<MemoPlan> {
  /**
   * The plaintext.
   *
   * @generated from field: bytes plaintext = 1;
   */
  plaintext = new Uint8Array(0);

  /**
   * The key to use to encrypt the memo.
   *
   * @generated from field: bytes key = 2;
   */
  key = new Uint8Array(0);

  constructor(data?: PartialMessage<MemoPlan>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "penumbra.transaction.MemoPlan";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "plaintext", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 2, name: "key", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MemoPlan {
    return new MemoPlan().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MemoPlan {
    return new MemoPlan().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MemoPlan {
    return new MemoPlan().fromJsonString(jsonString, options);
  }

  static equals(a: MemoPlan | PlainMessage<MemoPlan> | undefined, b: MemoPlan | PlainMessage<MemoPlan> | undefined): boolean {
    return proto3.util.equals(MemoPlan, a, b);
  }
}

/**
 * @generated from message penumbra.transaction.SpendPlan
 */
export class SpendPlan extends Message<SpendPlan> {
  /**
   * The plaintext note we plan to spend.
   *
   * @generated from field: penumbra.crypto.Note note = 1;
   */
  note?: Note;

  /**
   * The position of the note we plan to spend.
   *
   * @generated from field: uint64 position = 2;
   */
  position = protoInt64.zero;

  /**
   * The randomizer to use for the spend.
   *
   * @generated from field: bytes randomizer = 3;
   */
  randomizer = new Uint8Array(0);

  /**
   * The blinding factor to use for the value commitment.
   *
   * @generated from field: bytes value_blinding = 4;
   */
  valueBlinding = new Uint8Array(0);

  constructor(data?: PartialMessage<SpendPlan>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "penumbra.transaction.SpendPlan";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "note", kind: "message", T: Note },
    { no: 2, name: "position", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 3, name: "randomizer", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 4, name: "value_blinding", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SpendPlan {
    return new SpendPlan().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SpendPlan {
    return new SpendPlan().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SpendPlan {
    return new SpendPlan().fromJsonString(jsonString, options);
  }

  static equals(a: SpendPlan | PlainMessage<SpendPlan> | undefined, b: SpendPlan | PlainMessage<SpendPlan> | undefined): boolean {
    return proto3.util.equals(SpendPlan, a, b);
  }
}

/**
 * @generated from message penumbra.transaction.OutputPlan
 */
export class OutputPlan extends Message<OutputPlan> {
  /**
   * The value to send to this output.
   *
   * @generated from field: penumbra.crypto.Value value = 1;
   */
  value?: Value;

  /**
   * The destination address to send it to.
   *
   * @generated from field: penumbra.crypto.Address dest_address = 2;
   */
  destAddress?: Address;

  /**
   * The blinding factor to use for the new note.
   *
   * @generated from field: bytes note_blinding = 3;
   */
  noteBlinding = new Uint8Array(0);

  /**
   * The blinding factor to use for the value commitment.
   *
   * @generated from field: bytes value_blinding = 4;
   */
  valueBlinding = new Uint8Array(0);

  /**
   * The ephemeral secret key to use for the note encryption.
   *
   * @generated from field: bytes esk = 5;
   */
  esk = new Uint8Array(0);

  constructor(data?: PartialMessage<OutputPlan>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "penumbra.transaction.OutputPlan";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "value", kind: "message", T: Value },
    { no: 2, name: "dest_address", kind: "message", T: Address },
    { no: 3, name: "note_blinding", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 4, name: "value_blinding", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 5, name: "esk", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): OutputPlan {
    return new OutputPlan().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): OutputPlan {
    return new OutputPlan().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): OutputPlan {
    return new OutputPlan().fromJsonString(jsonString, options);
  }

  static equals(a: OutputPlan | PlainMessage<OutputPlan> | undefined, b: OutputPlan | PlainMessage<OutputPlan> | undefined): boolean {
    return proto3.util.equals(OutputPlan, a, b);
  }
}

/**
 * @generated from message penumbra.transaction.SwapPlan
 */
export class SwapPlan extends Message<SwapPlan> {
  /**
   * The plaintext version of the swap to be performed.
   *
   * @generated from field: penumbra.dex.SwapPlaintext swap_plaintext = 1;
   */
  swapPlaintext?: SwapPlaintext;

  /**
   * The blinding factor for the fee commitment. The fee in the SwapPlan is private to prevent linkability with the SwapClaim.
   *
   * @generated from field: bytes fee_blinding = 5;
   */
  feeBlinding = new Uint8Array(0);

  /**
   * The blinding factor to use for the new swap NFT note.
   *
   * @generated from field: bytes note_blinding = 7;
   */
  noteBlinding = new Uint8Array(0);

  /**
   * The ephemeral secret key to use for the swap NFT note encryption.
   *
   * @generated from field: bytes esk = 8;
   */
  esk = new Uint8Array(0);

  constructor(data?: PartialMessage<SwapPlan>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "penumbra.transaction.SwapPlan";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "swap_plaintext", kind: "message", T: SwapPlaintext },
    { no: 5, name: "fee_blinding", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 7, name: "note_blinding", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 8, name: "esk", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SwapPlan {
    return new SwapPlan().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SwapPlan {
    return new SwapPlan().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SwapPlan {
    return new SwapPlan().fromJsonString(jsonString, options);
  }

  static equals(a: SwapPlan | PlainMessage<SwapPlan> | undefined, b: SwapPlan | PlainMessage<SwapPlan> | undefined): boolean {
    return proto3.util.equals(SwapPlan, a, b);
  }
}

/**
 *
 * @exclude
 * Fields describing the swap NFT note to be redeemed.
 *
 * @generated from message penumbra.transaction.SwapClaimPlan
 */
export class SwapClaimPlan extends Message<SwapClaimPlan> {
  /**
   * The input swap NFT note to be spent.
   *
   * @generated from field: penumbra.crypto.Note swap_nft_note = 1;
   */
  swapNftNote?: Note;

  /**
   * The position of the input swap NFT note.
   *
   * @generated from field: uint64 swap_nft_position = 2;
   */
  swapNftPosition = protoInt64.zero;

  /**
   * The plaintext version of the swap to be performed.
   *
   * @generated from field: penumbra.dex.SwapPlaintext swap_plaintext = 3;
   */
  swapPlaintext?: SwapPlaintext;

  /**
   * Input and output amounts for the Swap.
   *
   * @generated from field: penumbra.dex.BatchSwapOutputData output_data = 11;
   */
  outputData?: BatchSwapOutputData;

  /**
   * The blinding factor used for the first output note.
   *
   * @generated from field: bytes output_1_blinding = 15;
   */
  output1Blinding = new Uint8Array(0);

  /**
   * The blinding factor used for the second output note.
   *
   * @generated from field: bytes output_2_blinding = 16;
   */
  output2Blinding = new Uint8Array(0);

  /**
   * The ephemeral secret key used for the first output note encryption.
   *
   * @generated from field: bytes esk_1 = 17;
   */
  esk1 = new Uint8Array(0);

  /**
   * The ephemeral secret key used for the second output note encryption.
   *
   * @generated from field: bytes esk_2 = 18;
   */
  esk2 = new Uint8Array(0);

  /**
   * The epoch duration when the swap claim took place.
   *
   * @generated from field: uint64 epoch_duration = 20;
   */
  epochDuration = protoInt64.zero;

  constructor(data?: PartialMessage<SwapClaimPlan>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "penumbra.transaction.SwapClaimPlan";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "swap_nft_note", kind: "message", T: Note },
    { no: 2, name: "swap_nft_position", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 3, name: "swap_plaintext", kind: "message", T: SwapPlaintext },
    { no: 11, name: "output_data", kind: "message", T: BatchSwapOutputData },
    { no: 15, name: "output_1_blinding", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 16, name: "output_2_blinding", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 17, name: "esk_1", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 18, name: "esk_2", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 20, name: "epoch_duration", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SwapClaimPlan {
    return new SwapClaimPlan().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SwapClaimPlan {
    return new SwapClaimPlan().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SwapClaimPlan {
    return new SwapClaimPlan().fromJsonString(jsonString, options);
  }

  static equals(a: SwapClaimPlan | PlainMessage<SwapClaimPlan> | undefined, b: SwapClaimPlan | PlainMessage<SwapClaimPlan> | undefined): boolean {
    return proto3.util.equals(SwapClaimPlan, a, b);
  }
}

/**
 * @generated from message penumbra.transaction.ProposalWithdrawPlan
 */
export class ProposalWithdrawPlan extends Message<ProposalWithdrawPlan> {
  /**
   * The body of the proposal withdrawal.
   *
   * @generated from field: penumbra.transaction.ProposalWithdrawBody body = 1;
   */
  body?: ProposalWithdrawBody;

  /**
   * The randomizer to use for signing the proposal withdrawal.
   *
   * @generated from field: bytes randomizer = 2;
   */
  randomizer = new Uint8Array(0);

  constructor(data?: PartialMessage<ProposalWithdrawPlan>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "penumbra.transaction.ProposalWithdrawPlan";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "body", kind: "message", T: ProposalWithdrawBody },
    { no: 2, name: "randomizer", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ProposalWithdrawPlan {
    return new ProposalWithdrawPlan().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ProposalWithdrawPlan {
    return new ProposalWithdrawPlan().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ProposalWithdrawPlan {
    return new ProposalWithdrawPlan().fromJsonString(jsonString, options);
  }

  static equals(a: ProposalWithdrawPlan | PlainMessage<ProposalWithdrawPlan> | undefined, b: ProposalWithdrawPlan | PlainMessage<ProposalWithdrawPlan> | undefined): boolean {
    return proto3.util.equals(ProposalWithdrawPlan, a, b);
  }
}

/**
 * @generated from message penumbra.transaction.DelegatorVotePlan
 */
export class DelegatorVotePlan extends Message<DelegatorVotePlan> {
  /**
   * The proposal to vote on.
   *
   * @generated from field: uint64 proposal = 1;
   */
  proposal = protoInt64.zero;

  /**
   * The vote to cast.
   *
   * @generated from field: penumbra.governance.Vote vote = 2;
   */
  vote?: Vote;

  /**
   * The delegation note to prove that we can vote.
   *
   * @generated from field: penumbra.crypto.Note staked_note = 3;
   */
  stakedNote?: Note;

  /**
   * The position of that delegation note.
   *
   * @generated from field: uint64 position = 4;
   */
  position = protoInt64.zero;

  /**
   * The randomizer to use for the proof of spend capability.
   *
   * @generated from field: bytes randomizer = 5;
   */
  randomizer = new Uint8Array(0);

  constructor(data?: PartialMessage<DelegatorVotePlan>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "penumbra.transaction.DelegatorVotePlan";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "proposal", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 2, name: "vote", kind: "message", T: Vote },
    { no: 3, name: "staked_note", kind: "message", T: Note },
    { no: 4, name: "position", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 5, name: "randomizer", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DelegatorVotePlan {
    return new DelegatorVotePlan().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DelegatorVotePlan {
    return new DelegatorVotePlan().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DelegatorVotePlan {
    return new DelegatorVotePlan().fromJsonString(jsonString, options);
  }

  static equals(a: DelegatorVotePlan | PlainMessage<DelegatorVotePlan> | undefined, b: DelegatorVotePlan | PlainMessage<DelegatorVotePlan> | undefined): boolean {
    return proto3.util.equals(DelegatorVotePlan, a, b);
  }
}

/**
 * A proposal to be voted upon.
 *
 * @generated from message penumbra.transaction.Proposal
 */
export class Proposal extends Message<Proposal> {
  /**
   * @generated from field: string title = 1;
   */
  title = "";

  /**
   * A natural-language description of the effect of the proposal and its justification.
   *
   * @generated from field: string description = 2;
   */
  description = "";

  /**
   * The payload of the proposal.
   *
   * @generated from field: penumbra.transaction.Proposal.Payload payload = 3;
   */
  payload?: Proposal_Payload;

  constructor(data?: PartialMessage<Proposal>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "penumbra.transaction.Proposal";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "title", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "description", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "payload", kind: "message", T: Proposal_Payload },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Proposal {
    return new Proposal().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Proposal {
    return new Proposal().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Proposal {
    return new Proposal().fromJsonString(jsonString, options);
  }

  static equals(a: Proposal | PlainMessage<Proposal> | undefined, b: Proposal | PlainMessage<Proposal> | undefined): boolean {
    return proto3.util.equals(Proposal, a, b);
  }
}

/**
 * The kind of the proposal and details relevant only to that kind of proposal.
 *
 * @generated from message penumbra.transaction.Proposal.Payload
 */
export class Proposal_Payload extends Message<Proposal_Payload> {
  /**
   * @generated from oneof penumbra.transaction.Proposal.Payload.payload
   */
  payload: {
    /**
     * A signaling proposal.
     *
     * @generated from field: penumbra.transaction.Proposal.Signaling signaling = 2;
     */
    value: Proposal_Signaling;
    case: "signaling";
  } | {
    /**
     * An emergency proposal.
     *
     * @generated from field: penumbra.transaction.Proposal.Emergency emergency = 3;
     */
    value: Proposal_Emergency;
    case: "emergency";
  } | {
    /**
     * A parameter change proposal.
     *
     * @generated from field: penumbra.transaction.Proposal.ParameterChange parameter_change = 4;
     */
    value: Proposal_ParameterChange;
    case: "parameterChange";
  } | {
    /**
     * A DAO spend proposal.
     *
     * @generated from field: penumbra.transaction.Proposal.DaoSpend dao_spend = 5;
     */
    value: Proposal_DaoSpend;
    case: "daoSpend";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<Proposal_Payload>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "penumbra.transaction.Proposal.Payload";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 2, name: "signaling", kind: "message", T: Proposal_Signaling, oneof: "payload" },
    { no: 3, name: "emergency", kind: "message", T: Proposal_Emergency, oneof: "payload" },
    { no: 4, name: "parameter_change", kind: "message", T: Proposal_ParameterChange, oneof: "payload" },
    { no: 5, name: "dao_spend", kind: "message", T: Proposal_DaoSpend, oneof: "payload" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Proposal_Payload {
    return new Proposal_Payload().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Proposal_Payload {
    return new Proposal_Payload().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Proposal_Payload {
    return new Proposal_Payload().fromJsonString(jsonString, options);
  }

  static equals(a: Proposal_Payload | PlainMessage<Proposal_Payload> | undefined, b: Proposal_Payload | PlainMessage<Proposal_Payload> | undefined): boolean {
    return proto3.util.equals(Proposal_Payload, a, b);
  }
}

/**
 * It optionally contains a reference to a commit which contains code to upgrade the chain.
 *
 * @generated from message penumbra.transaction.Proposal.Signaling
 */
export class Proposal_Signaling extends Message<Proposal_Signaling> {
  /**
   * The commit to be voted upon, if any is relevant.
   *
   * @generated from field: optional string commit = 1;
   */
  commit?: string;

  constructor(data?: PartialMessage<Proposal_Signaling>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "penumbra.transaction.Proposal.Signaling";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "commit", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Proposal_Signaling {
    return new Proposal_Signaling().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Proposal_Signaling {
    return new Proposal_Signaling().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Proposal_Signaling {
    return new Proposal_Signaling().fromJsonString(jsonString, options);
  }

  static equals(a: Proposal_Signaling | PlainMessage<Proposal_Signaling> | undefined, b: Proposal_Signaling | PlainMessage<Proposal_Signaling> | undefined): boolean {
    return proto3.util.equals(Proposal_Signaling, a, b);
  }
}

/**
 * An emergency proposal can be passed instantaneously by a 2/3 majority of validators, without
 * waiting for the voting period to expire.
 *
 * If the boolean `halt_chain` is set to `true`, then the chain will halt immediately when the
 * proposal is passed.
 *
 * @generated from message penumbra.transaction.Proposal.Emergency
 */
export class Proposal_Emergency extends Message<Proposal_Emergency> {
  /**
   * If `true`, the chain will halt immediately when the proposal is passed.
   *
   * @generated from field: bool halt_chain = 1;
   */
  haltChain = false;

  constructor(data?: PartialMessage<Proposal_Emergency>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "penumbra.transaction.Proposal.Emergency";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "halt_chain", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Proposal_Emergency {
    return new Proposal_Emergency().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Proposal_Emergency {
    return new Proposal_Emergency().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Proposal_Emergency {
    return new Proposal_Emergency().fromJsonString(jsonString, options);
  }

  static equals(a: Proposal_Emergency | PlainMessage<Proposal_Emergency> | undefined, b: Proposal_Emergency | PlainMessage<Proposal_Emergency> | undefined): boolean {
    return proto3.util.equals(Proposal_Emergency, a, b);
  }
}

/**
 * A parameter change proposal describes an alteration to one or more chain parameters, which
 * should take effect at a particular block height `effective_height` (which should be at least
 * the height when the proposal would be passed).
 *
 * @generated from message penumbra.transaction.Proposal.ParameterChange
 */
export class Proposal_ParameterChange extends Message<Proposal_ParameterChange> {
  /**
   * The height at which the change should take effect.
   *
   * @generated from field: uint64 effective_height = 1;
   */
  effectiveHeight = protoInt64.zero;

  /**
   * The set of changes to chain parameters.
   *
   * @generated from field: repeated penumbra.transaction.Proposal.ParameterChange.SetParameter new_parameters = 2;
   */
  newParameters: Proposal_ParameterChange_SetParameter[] = [];

  constructor(data?: PartialMessage<Proposal_ParameterChange>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "penumbra.transaction.Proposal.ParameterChange";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "effective_height", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 2, name: "new_parameters", kind: "message", T: Proposal_ParameterChange_SetParameter, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Proposal_ParameterChange {
    return new Proposal_ParameterChange().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Proposal_ParameterChange {
    return new Proposal_ParameterChange().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Proposal_ParameterChange {
    return new Proposal_ParameterChange().fromJsonString(jsonString, options);
  }

  static equals(a: Proposal_ParameterChange | PlainMessage<Proposal_ParameterChange> | undefined, b: Proposal_ParameterChange | PlainMessage<Proposal_ParameterChange> | undefined): boolean {
    return proto3.util.equals(Proposal_ParameterChange, a, b);
  }
}

/**
 * A single change to an individual chain parameter.
 *
 * @generated from message penumbra.transaction.Proposal.ParameterChange.SetParameter
 */
export class Proposal_ParameterChange_SetParameter extends Message<Proposal_ParameterChange_SetParameter> {
  /**
   * The name of the parameter.
   *
   * @generated from field: string parameter = 1;
   */
  parameter = "";

  /**
   * Its new value, as a string (this will be parsed as appropriate for the parameter's type).
   *
   * @generated from field: string value = 2;
   */
  value = "";

  constructor(data?: PartialMessage<Proposal_ParameterChange_SetParameter>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "penumbra.transaction.Proposal.ParameterChange.SetParameter";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "parameter", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "value", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Proposal_ParameterChange_SetParameter {
    return new Proposal_ParameterChange_SetParameter().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Proposal_ParameterChange_SetParameter {
    return new Proposal_ParameterChange_SetParameter().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Proposal_ParameterChange_SetParameter {
    return new Proposal_ParameterChange_SetParameter().fromJsonString(jsonString, options);
  }

  static equals(a: Proposal_ParameterChange_SetParameter | PlainMessage<Proposal_ParameterChange_SetParameter> | undefined, b: Proposal_ParameterChange_SetParameter | PlainMessage<Proposal_ParameterChange_SetParameter> | undefined): boolean {
    return proto3.util.equals(Proposal_ParameterChange_SetParameter, a, b);
  }
}

/**
 * A DAO spend proposal describes zero or more transactions to execute on behalf of the DAO, with
 * access to its funds, and zero or more scheduled transactions from previous passed proposals to
 * cancel.
 *
 * @generated from message penumbra.transaction.Proposal.DaoSpend
 */
export class Proposal_DaoSpend extends Message<Proposal_DaoSpend> {
  /**
   * The sequence of transactions to schedule for execution.
   *
   * @generated from field: repeated penumbra.transaction.Proposal.DaoSpend.ScheduleTransaction schedule_transactions = 1;
   */
  scheduleTransactions: Proposal_DaoSpend_ScheduleTransaction[] = [];

  /**
   * A sequence of previously-scheduled transactions to cancel before they are executed.
   *
   * @generated from field: repeated penumbra.transaction.Proposal.DaoSpend.CancelTransaction cancel_transactions = 2;
   */
  cancelTransactions: Proposal_DaoSpend_CancelTransaction[] = [];

  constructor(data?: PartialMessage<Proposal_DaoSpend>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "penumbra.transaction.Proposal.DaoSpend";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "schedule_transactions", kind: "message", T: Proposal_DaoSpend_ScheduleTransaction, repeated: true },
    { no: 2, name: "cancel_transactions", kind: "message", T: Proposal_DaoSpend_CancelTransaction, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Proposal_DaoSpend {
    return new Proposal_DaoSpend().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Proposal_DaoSpend {
    return new Proposal_DaoSpend().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Proposal_DaoSpend {
    return new Proposal_DaoSpend().fromJsonString(jsonString, options);
  }

  static equals(a: Proposal_DaoSpend | PlainMessage<Proposal_DaoSpend> | undefined, b: Proposal_DaoSpend | PlainMessage<Proposal_DaoSpend> | undefined): boolean {
    return proto3.util.equals(Proposal_DaoSpend, a, b);
  }
}

/**
 * A transaction to be executed as a consequence of this proposal.
 *
 * It is permissible for there to be duplicate transactions scheduled for a given height; they
 * will both be executed.
 *
 * @generated from message penumbra.transaction.Proposal.DaoSpend.ScheduleTransaction
 */
export class Proposal_DaoSpend_ScheduleTransaction extends Message<Proposal_DaoSpend_ScheduleTransaction> {
  /**
   * The height at which the transaction should be executed.
   *
   * @generated from field: uint64 execute_at_height = 1;
   */
  executeAtHeight = protoInt64.zero;

  /**
   * The transaction to be executed.
   *
   * @generated from field: penumbra.transaction.TransactionPlan transaction = 2;
   */
  transaction?: TransactionPlan;

  constructor(data?: PartialMessage<Proposal_DaoSpend_ScheduleTransaction>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "penumbra.transaction.Proposal.DaoSpend.ScheduleTransaction";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "execute_at_height", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 2, name: "transaction", kind: "message", T: TransactionPlan },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Proposal_DaoSpend_ScheduleTransaction {
    return new Proposal_DaoSpend_ScheduleTransaction().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Proposal_DaoSpend_ScheduleTransaction {
    return new Proposal_DaoSpend_ScheduleTransaction().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Proposal_DaoSpend_ScheduleTransaction {
    return new Proposal_DaoSpend_ScheduleTransaction().fromJsonString(jsonString, options);
  }

  static equals(a: Proposal_DaoSpend_ScheduleTransaction | PlainMessage<Proposal_DaoSpend_ScheduleTransaction> | undefined, b: Proposal_DaoSpend_ScheduleTransaction | PlainMessage<Proposal_DaoSpend_ScheduleTransaction> | undefined): boolean {
    return proto3.util.equals(Proposal_DaoSpend_ScheduleTransaction, a, b);
  }
}

/**
 * A transaction to be canceled as a consequence of this proposal.
 *
 * If there are multiple duplicate transactions at the height, this cancels only the first.
 * To cancel more of them, specify duplicate cancellations.
 *
 * @generated from message penumbra.transaction.Proposal.DaoSpend.CancelTransaction
 */
export class Proposal_DaoSpend_CancelTransaction extends Message<Proposal_DaoSpend_CancelTransaction> {
  /**
   * The height for which the transaction was scheduled.
   *
   * @generated from field: uint64 scheduled_at_height = 1;
   */
  scheduledAtHeight = protoInt64.zero;

  /**
   * The auth hash of the transaction to cancel.
   *
   * @generated from field: penumbra.transaction.AuthHash auth_hash = 2;
   */
  authHash?: AuthHash;

  constructor(data?: PartialMessage<Proposal_DaoSpend_CancelTransaction>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "penumbra.transaction.Proposal.DaoSpend.CancelTransaction";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "scheduled_at_height", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 2, name: "auth_hash", kind: "message", T: AuthHash },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Proposal_DaoSpend_CancelTransaction {
    return new Proposal_DaoSpend_CancelTransaction().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Proposal_DaoSpend_CancelTransaction {
    return new Proposal_DaoSpend_CancelTransaction().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Proposal_DaoSpend_CancelTransaction {
    return new Proposal_DaoSpend_CancelTransaction().fromJsonString(jsonString, options);
  }

  static equals(a: Proposal_DaoSpend_CancelTransaction | PlainMessage<Proposal_DaoSpend_CancelTransaction> | undefined, b: Proposal_DaoSpend_CancelTransaction | PlainMessage<Proposal_DaoSpend_CancelTransaction> | undefined): boolean {
    return proto3.util.equals(Proposal_DaoSpend_CancelTransaction, a, b);
  }
}

