// @generated by protoc-gen-es v0.1.1 with parameter "target=ts"
// @generated from file transparent_proofs.proto (package penumbra.transparent_proofs, syntax proto3)
/* eslint-disable */
/* @ts-nocheck */

import type {BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage} from "@bufbuild/protobuf";
import {Message, proto3, protoInt64} from "@bufbuild/protobuf";
import {Address, Fee, NoteCommitmentProof} from "./crypto_pb.js";
import {TradingPair} from "./dex_pb.js";

/**
 * A Penumbra transparent Spend Proof.
 *
 * @generated from message penumbra.transparent_proofs.SpendProof
 */
export class SpendProof extends Message<SpendProof> {
  /**
   * Auxiliary inputs
   *
   * @generated from field: penumbra.crypto.NoteCommitmentProof note_commitment_proof = 1;
   */
  noteCommitmentProof?: NoteCommitmentProof;

  /**
   *
   * @exclude
   * From the note being spent
   *
   * @generated from field: bytes g_d = 2;
   */
  gD = new Uint8Array(0);

  /**
   * @generated from field: bytes pk_d = 3;
   */
  pkD = new Uint8Array(0);

  /**
   * @generated from field: uint64 value_amount = 4;
   */
  valueAmount = protoInt64.zero;

  /**
   * @generated from field: bytes value_asset_id = 5;
   */
  valueAssetId = new Uint8Array(0);

  /**
   * @generated from field: bytes v_blinding = 6;
   */
  vBlinding = new Uint8Array(0);

  /**
   * @generated from field: bytes note_blinding = 8;
   */
  noteBlinding = new Uint8Array(0);

  /**
   * @generated from field: bytes spend_auth_randomizer = 9;
   */
  spendAuthRandomizer = new Uint8Array(0);

  /**
   * @generated from field: bytes ak = 10;
   */
  ak = new Uint8Array(0);

  /**
   * @generated from field: bytes nk = 11;
   */
  nk = new Uint8Array(0);

  /**
   * @generated from field: bytes ck_d = 12;
   */
  ckD = new Uint8Array(0);

  constructor(data?: PartialMessage<SpendProof>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "penumbra.transparent_proofs.SpendProof";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "note_commitment_proof", kind: "message", T: NoteCommitmentProof },
    { no: 2, name: "g_d", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 3, name: "pk_d", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 4, name: "value_amount", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 5, name: "value_asset_id", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 6, name: "v_blinding", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 8, name: "note_blinding", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 9, name: "spend_auth_randomizer", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 10, name: "ak", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 11, name: "nk", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 12, name: "ck_d", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SpendProof {
    return new SpendProof().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SpendProof {
    return new SpendProof().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SpendProof {
    return new SpendProof().fromJsonString(jsonString, options);
  }

  static equals(a: SpendProof | PlainMessage<SpendProof> | undefined, b: SpendProof | PlainMessage<SpendProof> | undefined): boolean {
    return proto3.util.equals(SpendProof, a, b);
  }
}

/**
 * A Penumbra transparent output proof.
 *
 * @generated from message penumbra.transparent_proofs.OutputProof
 */
export class OutputProof extends Message<OutputProof> {
  /**
   * Auxiliary inputs
   *
   * @generated from field: bytes g_d = 1;
   */
  gD = new Uint8Array(0);

  /**
   * @generated from field: bytes pk_d = 2;
   */
  pkD = new Uint8Array(0);

  /**
   * @generated from field: uint64 value_amount = 3;
   */
  valueAmount = protoInt64.zero;

  /**
   * @generated from field: bytes value_asset_id = 4;
   */
  valueAssetId = new Uint8Array(0);

  /**
   * @generated from field: bytes v_blinding = 5;
   */
  vBlinding = new Uint8Array(0);

  /**
   * @generated from field: bytes note_blinding = 6;
   */
  noteBlinding = new Uint8Array(0);

  /**
   * @generated from field: bytes esk = 7;
   */
  esk = new Uint8Array(0);

  /**
   * @generated from field: bytes ck_d = 8;
   */
  ckD = new Uint8Array(0);

  constructor(data?: PartialMessage<OutputProof>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "penumbra.transparent_proofs.OutputProof";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "g_d", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 2, name: "pk_d", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 3, name: "value_amount", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 4, name: "value_asset_id", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 5, name: "v_blinding", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 6, name: "note_blinding", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 7, name: "esk", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 8, name: "ck_d", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): OutputProof {
    return new OutputProof().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): OutputProof {
    return new OutputProof().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): OutputProof {
    return new OutputProof().fromJsonString(jsonString, options);
  }

  static equals(a: OutputProof | PlainMessage<OutputProof> | undefined, b: OutputProof | PlainMessage<OutputProof> | undefined): boolean {
    return proto3.util.equals(OutputProof, a, b);
  }
}

/**
 * A Penumbra transparent SwapClaimProof.
 *
 * @generated from message penumbra.transparent_proofs.SwapClaimProof
 */
export class SwapClaimProof extends Message<SwapClaimProof> {
  /**
   *
   * @exclude
   * Describes the input note with the Swap NFT
   *
   * @generated from field: bytes swap_nft_asset_id = 1;
   */
  swapNftAssetId = new Uint8Array(0);

  /**
   * @generated from field: penumbra.crypto.Address claim_address = 2;
   */
  claimAddress?: Address;

  /**
   * Inclusion proof for the Swap NFT
   *
   * @generated from field: penumbra.crypto.NoteCommitmentProof note_commitment_proof = 4;
   */
  noteCommitmentProof?: NoteCommitmentProof;

  /**
   * @generated from field: bytes note_blinding = 5;
   */
  noteBlinding = new Uint8Array(0);

  /**
   * @generated from field: bytes nk = 6;
   */
  nk = new Uint8Array(0);

  /**
   *
   * @exclude
   * Describes opening of Swap NFT asset ID for commitment verification
   *
   * @generated from field: penumbra.dex.TradingPair trading_pair = 10;
   */
  tradingPair?: TradingPair;

  /**
   * uint64 fee = 7; // fee is public data so not included in client's submitted SwapClaimProof
   * The user's contribution to the swap
   *
   * @generated from field: uint64 delta_1_i = 11;
   */
  delta1I = protoInt64.zero;

  /**
   * @generated from field: uint64 delta_2_i = 12;
   */
  delta2I = protoInt64.zero;

  /**
   *
   * @exclude
   * Describes output amounts
   *
   * @generated from field: uint64 lambda_1 = 20;
   */
  lambda1 = protoInt64.zero;

  /**
   * @generated from field: uint64 lambda_2 = 21;
   */
  lambda2 = protoInt64.zero;

  /**
   *
   * @exclude
   * Describes first output note (lambda 1)
   *
   * @generated from field: bytes note_blinding_1 = 30;
   */
  noteBlinding1 = new Uint8Array(0);

  /**
   * @generated from field: bytes esk_1 = 31;
   */
  esk1 = new Uint8Array(0);

  /**
   *
   * @exclude
   * Describes second output note (lambda 2)
   *
   * @generated from field: bytes note_blinding_2 = 40;
   */
  noteBlinding2 = new Uint8Array(0);

  /**
   * @generated from field: bytes esk_2 = 41;
   */
  esk2 = new Uint8Array(0);

  constructor(data?: PartialMessage<SwapClaimProof>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "penumbra.transparent_proofs.SwapClaimProof";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "swap_nft_asset_id", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 2, name: "claim_address", kind: "message", T: Address },
    { no: 4, name: "note_commitment_proof", kind: "message", T: NoteCommitmentProof },
    { no: 5, name: "note_blinding", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 6, name: "nk", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 10, name: "trading_pair", kind: "message", T: TradingPair },
    { no: 11, name: "delta_1_i", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 12, name: "delta_2_i", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 20, name: "lambda_1", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 21, name: "lambda_2", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 30, name: "note_blinding_1", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 31, name: "esk_1", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 40, name: "note_blinding_2", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 41, name: "esk_2", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SwapClaimProof {
    return new SwapClaimProof().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SwapClaimProof {
    return new SwapClaimProof().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SwapClaimProof {
    return new SwapClaimProof().fromJsonString(jsonString, options);
  }

  static equals(a: SwapClaimProof | PlainMessage<SwapClaimProof> | undefined, b: SwapClaimProof | PlainMessage<SwapClaimProof> | undefined): boolean {
    return proto3.util.equals(SwapClaimProof, a, b);
  }
}

/**
 * A Penumbra transparent SwapProof.
 *
 *
 * @exclude
 * Describes swap inputs
 *
 * @generated from message penumbra.transparent_proofs.SwapProof
 */
export class SwapProof extends Message<SwapProof> {
  /**
   * Input amount of asset 1
   *
   * @generated from field: uint64 delta_1 = 1;
   */
  delta1 = protoInt64.zero;

  /**
   * Id of asset 1
   *
   * @generated from field: bytes t1 = 2;
   */
  t1 = new Uint8Array(0);

  /**
   * Input amount of asset 2
   *
   * @generated from field: uint64 delta_2 = 3;
   */
  delta2 = protoInt64.zero;

  /**
   * Id of asset 2
   *
   * @generated from field: bytes t2 = 4;
   */
  t2 = new Uint8Array(0);

  /**
   * Fee
   *
   * @generated from field: penumbra.crypto.Fee fee = 10;
   */
  fee?: Fee;

  /**
   * Fee blinding factor.
   *
   * @generated from field: bytes fee_blinding = 11;
   */
  feeBlinding = new Uint8Array(0);

  /**
   * Asset ID of the Swap NFT
   *
   * @generated from field: bytes swap_nft_asset_id = 30;
   */
  swapNftAssetId = new Uint8Array(0);

  /**
   * Address associated with the swap.
   *
   * @generated from field: penumbra.crypto.Address claim_address = 40;
   */
  claimAddress?: Address;

  /**
   * Note blinding factor
   *
   * @generated from field: bytes note_blinding = 42;
   */
  noteBlinding = new Uint8Array(0);

  /**
   * Ephemeral secret key
   *
   * @generated from field: bytes esk = 43;
   */
  esk = new Uint8Array(0);

  constructor(data?: PartialMessage<SwapProof>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "penumbra.transparent_proofs.SwapProof";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "delta_1", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 2, name: "t1", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 3, name: "delta_2", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 4, name: "t2", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 10, name: "fee", kind: "message", T: Fee },
    { no: 11, name: "fee_blinding", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 30, name: "swap_nft_asset_id", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 40, name: "claim_address", kind: "message", T: Address },
    { no: 42, name: "note_blinding", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 43, name: "esk", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SwapProof {
    return new SwapProof().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SwapProof {
    return new SwapProof().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SwapProof {
    return new SwapProof().fromJsonString(jsonString, options);
  }

  static equals(a: SwapProof | PlainMessage<SwapProof> | undefined, b: SwapProof | PlainMessage<SwapProof> | undefined): boolean {
    return proto3.util.equals(SwapProof, a, b);
  }
}

