// @generated by protoc-gen-es v0.1.1 with parameter "target=ts"
// @generated from file dex.proto (package penumbra.dex, syntax proto3)
/* eslint-disable */
/* @ts-nocheck */

import type {BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage} from "@bufbuild/protobuf";
import {Message, proto3, protoInt64} from "@bufbuild/protobuf";
import {Address, AssetId, Fee, NotePayload, Nullifier, ValueCommitment} from "./crypto_pb.js";

/**
 * A transaction action that submits a swap to the dex.
 *
 * @generated from message penumbra.dex.Swap
 */
export class Swap extends Message<Swap> {
  /**
   * Contains the Swap proof.
   *
   * @generated from field: bytes proof = 1;
   */
  proof = new Uint8Array(0);

  /**
   * MockFlowCiphertext dropped until flow encryption/ABCI++ available
   * // Encrypted amount of asset 1 of the trading pair.
   * MockFlowCiphertext enc_amount_1 = 2;
   * // Encrypted amount of asset 2 of the trading pair.
   * MockFlowCiphertext enc_amount_2 = 3;
   * Encapsulates the authorized fields of the Swap action, used in signing.
   *
   * @generated from field: penumbra.dex.SwapBody body = 4;
   */
  body?: SwapBody;

  constructor(data?: PartialMessage<Swap>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "penumbra.dex.Swap";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "proof", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 4, name: "body", kind: "message", T: SwapBody },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Swap {
    return new Swap().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Swap {
    return new Swap().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Swap {
    return new Swap().fromJsonString(jsonString, options);
  }

  static equals(a: Swap | PlainMessage<Swap> | undefined, b: Swap | PlainMessage<Swap> | undefined): boolean {
    return proto3.util.equals(Swap, a, b);
  }
}

/**
 * A transaction action that obtains assets previously confirmed
 * via a Swap transaction. Does not include a spend authorization
 * signature, as it is only capable of consuming the NFT from a
 * Swap transaction.
 *
 * @generated from message penumbra.dex.SwapClaim
 */
export class SwapClaim extends Message<SwapClaim> {
  /**
   * Contains the SwapClaim proof.
   *
   * @generated from field: bytes proof = 1;
   */
  proof = new Uint8Array(0);

  /**
   * Encapsulates the authorized fields of the SwapClaim action, used in signing.
   *
   * @generated from field: penumbra.dex.SwapClaimBody body = 2;
   */
  body?: SwapClaimBody;

  constructor(data?: PartialMessage<SwapClaim>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "penumbra.dex.SwapClaim";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "proof", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 2, name: "body", kind: "message", T: SwapClaimBody },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SwapClaim {
    return new SwapClaim().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SwapClaim {
    return new SwapClaim().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SwapClaim {
    return new SwapClaim().fromJsonString(jsonString, options);
  }

  static equals(a: SwapClaim | PlainMessage<SwapClaim> | undefined, b: SwapClaim | PlainMessage<SwapClaim> | undefined): boolean {
    return proto3.util.equals(SwapClaim, a, b);
  }
}

/**
 * Encapsulates the authorized fields of the SwapClaim action, used in signing.
 *
 * @generated from message penumbra.dex.SwapClaimBody
 */
export class SwapClaimBody extends Message<SwapClaimBody> {
  /**
   * The nullifier for the Swap NFT to be consumed.
   *
   * @generated from field: penumbra.crypto.Nullifier nullifier = 1;
   */
  nullifier?: Nullifier;

  /**
   * The fee allows `SwapClaim` without an additional `Spend`.
   *
   * @generated from field: penumbra.crypto.Fee fee = 2;
   */
  fee?: Fee;

  /**
   * Note output for asset 1.
   *
   * @generated from field: penumbra.crypto.NotePayload output_1 = 3;
   */
  output1?: NotePayload;

  /**
   * Note output for asset 2.
   *
   * @generated from field: penumbra.crypto.NotePayload output_2 = 4;
   */
  output2?: NotePayload;

  /**
   * Input and output amounts, and asset IDs for the assets in the swap.
   *
   * @generated from field: penumbra.dex.BatchSwapOutputData output_data = 6;
   */
  outputData?: BatchSwapOutputData;

  /**
   * The epoch duration of the chain when the swap claim took place.
   *
   * @generated from field: uint64 epoch_duration = 7;
   */
  epochDuration = protoInt64.zero;

  constructor(data?: PartialMessage<SwapClaimBody>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "penumbra.dex.SwapClaimBody";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "nullifier", kind: "message", T: Nullifier },
    { no: 2, name: "fee", kind: "message", T: Fee },
    { no: 3, name: "output_1", kind: "message", T: NotePayload },
    { no: 4, name: "output_2", kind: "message", T: NotePayload },
    { no: 6, name: "output_data", kind: "message", T: BatchSwapOutputData },
    { no: 7, name: "epoch_duration", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SwapClaimBody {
    return new SwapClaimBody().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SwapClaimBody {
    return new SwapClaimBody().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SwapClaimBody {
    return new SwapClaimBody().fromJsonString(jsonString, options);
  }

  static equals(a: SwapClaimBody | PlainMessage<SwapClaimBody> | undefined, b: SwapClaimBody | PlainMessage<SwapClaimBody> | undefined): boolean {
    return proto3.util.equals(SwapClaimBody, a, b);
  }
}

/**
 * For storing the list of claimed swaps between the dex and shielded pool components.
 *
 * @generated from message penumbra.dex.ClaimedSwapList
 */
export class ClaimedSwapList extends Message<ClaimedSwapList> {
  /**
   * @generated from field: repeated penumbra.dex.ClaimedSwap claims = 1;
   */
  claims: ClaimedSwap[] = [];

  constructor(data?: PartialMessage<ClaimedSwapList>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "penumbra.dex.ClaimedSwapList";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "claims", kind: "message", T: ClaimedSwap, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ClaimedSwapList {
    return new ClaimedSwapList().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ClaimedSwapList {
    return new ClaimedSwapList().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ClaimedSwapList {
    return new ClaimedSwapList().fromJsonString(jsonString, options);
  }

  static equals(a: ClaimedSwapList | PlainMessage<ClaimedSwapList> | undefined, b: ClaimedSwapList | PlainMessage<ClaimedSwapList> | undefined): boolean {
    return proto3.util.equals(ClaimedSwapList, a, b);
  }
}

/**
 * Represents a swap claimed in a particular transaction.
 *
 * @generated from message penumbra.dex.ClaimedSwap
 */
export class ClaimedSwap extends Message<ClaimedSwap> {
  /**
   * @generated from field: penumbra.dex.SwapClaimBody claim = 1;
   */
  claim?: SwapClaimBody;

  /**
   * @generated from field: bytes txid = 2;
   */
  txid = new Uint8Array(0);

  constructor(data?: PartialMessage<ClaimedSwap>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "penumbra.dex.ClaimedSwap";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "claim", kind: "message", T: SwapClaimBody },
    { no: 2, name: "txid", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ClaimedSwap {
    return new ClaimedSwap().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ClaimedSwap {
    return new ClaimedSwap().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ClaimedSwap {
    return new ClaimedSwap().fromJsonString(jsonString, options);
  }

  static equals(a: ClaimedSwap | PlainMessage<ClaimedSwap> | undefined, b: ClaimedSwap | PlainMessage<ClaimedSwap> | undefined): boolean {
    return proto3.util.equals(ClaimedSwap, a, b);
  }
}

/**
 * The authorized data of a Swap transaction.
 *
 * @generated from message penumbra.dex.SwapBody
 */
export class SwapBody extends Message<SwapBody> {
  /**
   * The trading pair to swap.
   *
   * @generated from field: penumbra.dex.TradingPair trading_pair = 1;
   */
  tradingPair?: TradingPair;

  /**
   * @exclude These will become commitments when flow encryption/ABCI++ are available
   * The amount for asset 1.
   *
   * @generated from field: uint64 delta_1_i = 2;
   */
  delta1I = protoInt64.zero;

  /**
   * The amount for asset 2.
   *
   * @generated from field: uint64 delta_2_i = 3;
   */
  delta2I = protoInt64.zero;

  /**
   * @exclude // Commitment to the amount for asset 1 (delta 1).
   * @exclude bytes delta_1_commitment = 2;
   * @exclude // Commitment to the amount for asset 2 (delta 2).
   * @exclude bytes delta_2_commitment = 3;
   * A commitment to a prepaid fee for the future SwapClaim.
   *
   * @generated from field: bytes fee_commitment = 4;
   */
  feeCommitment = new Uint8Array(0);

  /**
   * Swap NFT recording the user's contribution.
   *
   * @generated from field: penumbra.crypto.NotePayload swap_nft = 5;
   */
  swapNft?: NotePayload;

  /**
   * Encrypted version of the original `Swap`, symmetrically encrypted w/ viewing key.
   *
   * @generated from field: bytes swap_ciphertext = 6;
   */
  swapCiphertext = new Uint8Array(0);

  constructor(data?: PartialMessage<SwapBody>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "penumbra.dex.SwapBody";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "trading_pair", kind: "message", T: TradingPair },
    { no: 2, name: "delta_1_i", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 3, name: "delta_2_i", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 4, name: "fee_commitment", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 5, name: "swap_nft", kind: "message", T: NotePayload },
    { no: 6, name: "swap_ciphertext", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SwapBody {
    return new SwapBody().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SwapBody {
    return new SwapBody().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SwapBody {
    return new SwapBody().fromJsonString(jsonString, options);
  }

  static equals(a: SwapBody | PlainMessage<SwapBody> | undefined, b: SwapBody | PlainMessage<SwapBody> | undefined): boolean {
    return proto3.util.equals(SwapBody, a, b);
  }
}

/**
 * @generated from message penumbra.dex.SwapPlaintext
 */
export class SwapPlaintext extends Message<SwapPlaintext> {
  /**
   * The trading pair to swap.
   *
   * @generated from field: penumbra.dex.TradingPair trading_pair = 1;
   */
  tradingPair?: TradingPair;

  /**
   * User's input amount of asset 1
   *
   * @generated from field: uint64 delta_1_i = 2;
   */
  delta1I = protoInt64.zero;

  /**
   * User's input amount of asset 2
   *
   * @generated from field: uint64 delta_2_i = 3;
   */
  delta2I = protoInt64.zero;

  /**
   * Pre-paid fee to claim the swap
   *
   * @generated from field: penumbra.crypto.Fee claim_fee = 4;
   */
  claimFee?: Fee;

  /**
   * Address that will claim the swap outputs via SwapClaim.
   *
   * @generated from field: penumbra.crypto.Address claim_address = 5;
   */
  claimAddress?: Address;

  constructor(data?: PartialMessage<SwapPlaintext>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "penumbra.dex.SwapPlaintext";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "trading_pair", kind: "message", T: TradingPair },
    { no: 2, name: "delta_1_i", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 3, name: "delta_2_i", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 4, name: "claim_fee", kind: "message", T: Fee },
    { no: 5, name: "claim_address", kind: "message", T: Address },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SwapPlaintext {
    return new SwapPlaintext().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SwapPlaintext {
    return new SwapPlaintext().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SwapPlaintext {
    return new SwapPlaintext().fromJsonString(jsonString, options);
  }

  static equals(a: SwapPlaintext | PlainMessage<SwapPlaintext> | undefined, b: SwapPlaintext | PlainMessage<SwapPlaintext> | undefined): boolean {
    return proto3.util.equals(SwapPlaintext, a, b);
  }
}

/**
 * @generated from message penumbra.dex.MockFlowCiphertext
 */
export class MockFlowCiphertext extends Message<MockFlowCiphertext> {
  /**
   * Represents this transaction's contribution to flow's value.
   *
   * @generated from field: uint64 value = 1;
   */
  value = protoInt64.zero;

  constructor(data?: PartialMessage<MockFlowCiphertext>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "penumbra.dex.MockFlowCiphertext";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "value", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MockFlowCiphertext {
    return new MockFlowCiphertext().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MockFlowCiphertext {
    return new MockFlowCiphertext().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MockFlowCiphertext {
    return new MockFlowCiphertext().fromJsonString(jsonString, options);
  }

  static equals(a: MockFlowCiphertext | PlainMessage<MockFlowCiphertext> | undefined, b: MockFlowCiphertext | PlainMessage<MockFlowCiphertext> | undefined): boolean {
    return proto3.util.equals(MockFlowCiphertext, a, b);
  }
}

/**
 * Holds two asset IDs. Ordering doesn't reflect trading direction, however
 * since the `AssetId` type is `Ord + PartialOrd`, there can be only one
 * `TradingPair` per asset pair.
 *
 * @generated from message penumbra.dex.TradingPair
 */
export class TradingPair extends Message<TradingPair> {
  /**
   * The first asset of the pair.
   *
   * @generated from field: penumbra.crypto.AssetId asset_1 = 1;
   */
  asset1?: AssetId;

  /**
   * The second asset of the pair.
   *
   * @generated from field: penumbra.crypto.AssetId asset_2 = 2;
   */
  asset2?: AssetId;

  constructor(data?: PartialMessage<TradingPair>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "penumbra.dex.TradingPair";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "asset_1", kind: "message", T: AssetId },
    { no: 2, name: "asset_2", kind: "message", T: AssetId },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TradingPair {
    return new TradingPair().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TradingPair {
    return new TradingPair().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TradingPair {
    return new TradingPair().fromJsonString(jsonString, options);
  }

  static equals(a: TradingPair | PlainMessage<TradingPair> | undefined, b: TradingPair | PlainMessage<TradingPair> | undefined): boolean {
    return proto3.util.equals(TradingPair, a, b);
  }
}

/**
 * Records the result of a batch swap on-chain.
 *
 * Used as a public input to a swap claim proof, as it implies the effective
 * clearing price for the batch.
 *
 * @generated from message penumbra.dex.BatchSwapOutputData
 */
export class BatchSwapOutputData extends Message<BatchSwapOutputData> {
  /**
   * The total amount of asset 1 that was input to the batch swap.
   *
   * @generated from field: uint64 delta_1 = 1;
   */
  delta1 = protoInt64.zero;

  /**
   * The total amount of asset 2 that was input to the batch swap.
   *
   * @generated from field: uint64 delta_2 = 2;
   */
  delta2 = protoInt64.zero;

  /**
   * The total amount of asset 1 that was output from the batch swap.
   *
   * @generated from field: uint64 lambda_1 = 3;
   */
  lambda1 = protoInt64.zero;

  /**
   * The total amount of asset 2 that was output from the batch swap.
   *
   * @generated from field: uint64 lambda_2 = 4;
   */
  lambda2 = protoInt64.zero;

  /**
   * Whether the swap succeeded or not.
   *
   * @generated from field: bool success = 5;
   */
  success = false;

  /**
   * The height for which the batch swap data is valid.
   *
   * @generated from field: uint64 height = 6;
   */
  height = protoInt64.zero;

  /**
   * The trading pair associated with the batch swap.
   *
   * @generated from field: penumbra.dex.TradingPair trading_pair = 7;
   */
  tradingPair?: TradingPair;

  constructor(data?: PartialMessage<BatchSwapOutputData>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "penumbra.dex.BatchSwapOutputData";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "delta_1", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 2, name: "delta_2", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 3, name: "lambda_1", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 4, name: "lambda_2", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 5, name: "success", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 6, name: "height", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 7, name: "trading_pair", kind: "message", T: TradingPair },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): BatchSwapOutputData {
    return new BatchSwapOutputData().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): BatchSwapOutputData {
    return new BatchSwapOutputData().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): BatchSwapOutputData {
    return new BatchSwapOutputData().fromJsonString(jsonString, options);
  }

  static equals(a: BatchSwapOutputData | PlainMessage<BatchSwapOutputData> | undefined, b: BatchSwapOutputData | PlainMessage<BatchSwapOutputData> | undefined): boolean {
    return proto3.util.equals(BatchSwapOutputData, a, b);
  }
}

/**
 * The data describing a trading function.
 *
 * This implicitly treats the trading function as being between assets 1 and 2,
 * without specifying what those assets are, to avoid duplicating data (each
 * asset ID alone is twice the size of the trading function).
 *
 * The trading function is `phi(R) = p*R_1 + q*R_2`.
 * This is used as a CFMM with constant `k` and fee `fee` (gamma).
 *
 * @generated from message penumbra.dex.TradingFunction
 */
export class TradingFunction extends Message<TradingFunction> {
  /**
   * NOTE: the use of floats here is a placeholder, so we can stub out the
   * implementation and then decide what type of fixed-point, deterministic
   * arithmetic should be used.
   *
   * @generated from field: double fee = 2;
   */
  fee = 0;

  /**
   * @generated from field: double k = 3;
   */
  k = 0;

  /**
   * @generated from field: double p = 4;
   */
  p = 0;

  /**
   * @generated from field: double q = 5;
   */
  q = 0;

  constructor(data?: PartialMessage<TradingFunction>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "penumbra.dex.TradingFunction";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 2, name: "fee", kind: "scalar", T: 1 /* ScalarType.DOUBLE */ },
    { no: 3, name: "k", kind: "scalar", T: 1 /* ScalarType.DOUBLE */ },
    { no: 4, name: "p", kind: "scalar", T: 1 /* ScalarType.DOUBLE */ },
    { no: 5, name: "q", kind: "scalar", T: 1 /* ScalarType.DOUBLE */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TradingFunction {
    return new TradingFunction().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TradingFunction {
    return new TradingFunction().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TradingFunction {
    return new TradingFunction().fromJsonString(jsonString, options);
  }

  static equals(a: TradingFunction | PlainMessage<TradingFunction> | undefined, b: TradingFunction | PlainMessage<TradingFunction> | undefined): boolean {
    return proto3.util.equals(TradingFunction, a, b);
  }
}

/**
 * The reserves of a position.
 *
 * Like a position, this implicitly treats the trading function as being
 * between assets 1 and 2, without specifying what those assets are, to avoid
 * duplicating data (each asset ID alone is four times the size of the
 * reserves).
 *
 * @generated from message penumbra.dex.Reserves
 */
export class Reserves extends Message<Reserves> {
  /**
   * @generated from field: uint64 r1 = 1;
   */
  r1 = protoInt64.zero;

  /**
   * @generated from field: uint64 r2 = 2;
   */
  r2 = protoInt64.zero;

  constructor(data?: PartialMessage<Reserves>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "penumbra.dex.Reserves";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "r1", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 2, name: "r2", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Reserves {
    return new Reserves().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Reserves {
    return new Reserves().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Reserves {
    return new Reserves().fromJsonString(jsonString, options);
  }

  static equals(a: Reserves | PlainMessage<Reserves> | undefined, b: Reserves | PlainMessage<Reserves> | undefined): boolean {
    return proto3.util.equals(Reserves, a, b);
  }
}

/**
 * Data identifying a position.
 *
 * @generated from message penumbra.dex.Position
 */
export class Position extends Message<Position> {
  /**
   * @generated from field: penumbra.dex.TradingPair pair = 1;
   */
  pair?: TradingPair;

  /**
   * @generated from field: penumbra.dex.TradingFunction phi = 2;
   */
  phi?: TradingFunction;

  /**
   * A random value used to disambiguate different positions with the exact same
   * trading function.  The chain should reject newly created positions with the
   * same nonce as an existing position.  This ensures that `PositionId`s will
   * be unique, and allows us to track position ownership with a
   * sequence of stateful NFTs based on the `PositionId`.
   *
   * @generated from field: bytes nonce = 3;
   */
  nonce = new Uint8Array(0);

  constructor(data?: PartialMessage<Position>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "penumbra.dex.Position";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "pair", kind: "message", T: TradingPair },
    { no: 2, name: "phi", kind: "message", T: TradingFunction },
    { no: 3, name: "nonce", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Position {
    return new Position().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Position {
    return new Position().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Position {
    return new Position().fromJsonString(jsonString, options);
  }

  static equals(a: Position | PlainMessage<Position> | undefined, b: Position | PlainMessage<Position> | undefined): boolean {
    return proto3.util.equals(Position, a, b);
  }
}

/**
 * A hash of a `Position`.
 *
 * @generated from message penumbra.dex.PositionId
 */
export class PositionId extends Message<PositionId> {
  /**
   * @generated from field: bytes inner = 1;
   */
  inner = new Uint8Array(0);

  constructor(data?: PartialMessage<PositionId>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "penumbra.dex.PositionId";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "inner", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PositionId {
    return new PositionId().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PositionId {
    return new PositionId().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PositionId {
    return new PositionId().fromJsonString(jsonString, options);
  }

  static equals(a: PositionId | PlainMessage<PositionId> | undefined, b: PositionId | PlainMessage<PositionId> | undefined): boolean {
    return proto3.util.equals(PositionId, a, b);
  }
}

/**
 * The state of a position.
 *
 * @generated from message penumbra.dex.PositionState
 */
export class PositionState extends Message<PositionState> {
  /**
   * @generated from field: penumbra.dex.PositionState.PositionStateEnum state = 1;
   */
  state = PositionState_PositionStateEnum.OPENED;

  constructor(data?: PartialMessage<PositionState>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "penumbra.dex.PositionState";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "state", kind: "enum", T: proto3.getEnumType(PositionState_PositionStateEnum) },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PositionState {
    return new PositionState().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PositionState {
    return new PositionState().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PositionState {
    return new PositionState().fromJsonString(jsonString, options);
  }

  static equals(a: PositionState | PlainMessage<PositionState> | undefined, b: PositionState | PlainMessage<PositionState> | undefined): boolean {
    return proto3.util.equals(PositionState, a, b);
  }
}

/**
 * @generated from enum penumbra.dex.PositionState.PositionStateEnum
 */
export enum PositionState_PositionStateEnum {
  /**
   * The position has been opened, is active, has reserves and accumulated
   * fees, and can be traded against.
   *
   * @generated from enum value: OPENED = 0;
   */
  OPENED = 0,

  /**
   * The position has been closed, is inactive and can no longer be traded
   * against, but still has reserves and accumulated fees.
   *
   * @generated from enum value: CLOSED = 1;
   */
  CLOSED = 1,

  /**
   * The final reserves and accumulated fees have been withdrawn, leaving an
   * empty, inactive position awaiting (possible) retroactive rewards.
   *
   * @generated from enum value: WITHDRAWN = 2;
   */
  WITHDRAWN = 2,

  /**
   * Any retroactive rewards have been claimed. The position is now an inert,
   * historical artefact.
   *
   * @generated from enum value: CLAIMED = 3;
   */
  CLAIMED = 3,
}
// Retrieve enum metadata with: proto3.getEnumType(PositionState_PositionStateEnum)
proto3.util.setEnumType(PositionState_PositionStateEnum, "penumbra.dex.PositionState.PositionStateEnum", [
  { no: 0, name: "OPENED" },
  { no: 1, name: "CLOSED" },
  { no: 2, name: "WITHDRAWN" },
  { no: 3, name: "CLAIMED" },
]);

/**
 * An LPNFT tracking both ownership and state of a position.
 *
 * Tracking the state as part of the LPNFT means that all LP-related actions can
 * be authorized by spending funds: a state transition (e.g., closing a
 * position) is modeled as spending an "open position LPNFT" and minting a
 * "closed position LPNFT" for the same (globally unique) position ID.
 *
 * This means that the LP mechanics can be agnostic to the mechanism used to
 * record custody and spend authorization.  For instance, they can be recorded
 * in the shielded pool, where custody is based on off-chain keys, or they could
 * be recorded in a programmatic on-chain account (in the future, e.g., to
 * support interchain accounts).  This also means that LP-related actions don't
 * require any cryptographic implementation (proofs, signatures, etc), other
 * than hooking into the value commitment mechanism used for transaction
 * balances.
 *
 * @generated from message penumbra.dex.LpNft
 */
export class LpNft extends Message<LpNft> {
  /**
   * @generated from field: penumbra.dex.PositionId position_id = 1;
   */
  positionId?: PositionId;

  /**
   * @generated from field: penumbra.dex.PositionState state = 2;
   */
  state?: PositionState;

  constructor(data?: PartialMessage<LpNft>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "penumbra.dex.LpNft";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "position_id", kind: "message", T: PositionId },
    { no: 2, name: "state", kind: "message", T: PositionState },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): LpNft {
    return new LpNft().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): LpNft {
    return new LpNft().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): LpNft {
    return new LpNft().fromJsonString(jsonString, options);
  }

  static equals(a: LpNft | PlainMessage<LpNft> | undefined, b: LpNft | PlainMessage<LpNft> | undefined): boolean {
    return proto3.util.equals(LpNft, a, b);
  }
}

/**
 * A transaction action that opens a new position.
 *
 * This action's contribution to the transaction's value balance is to consume
 * the initial reserves and contribute an opened position NFT.
 *
 * @generated from message penumbra.dex.PositionOpen
 */
export class PositionOpen extends Message<PositionOpen> {
  /**
   * Contains the data defining the position, sufficient to compute its `PositionId`.
   *
   * Positions are immutable, so the `PositionData` (and hence the `PositionId`)
   * are unchanged over the entire lifetime of the position.
   *
   * @generated from field: penumbra.dex.Position position = 1;
   */
  position?: Position;

  /**
   * The initial reserves of the position.  Unlike the `PositionData`, the
   * reserves evolve over time as trades are executed against the position.
   *
   * @generated from field: penumbra.dex.Reserves initial_reserves = 2;
   */
  initialReserves?: Reserves;

  constructor(data?: PartialMessage<PositionOpen>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "penumbra.dex.PositionOpen";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "position", kind: "message", T: Position },
    { no: 2, name: "initial_reserves", kind: "message", T: Reserves },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PositionOpen {
    return new PositionOpen().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PositionOpen {
    return new PositionOpen().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PositionOpen {
    return new PositionOpen().fromJsonString(jsonString, options);
  }

  static equals(a: PositionOpen | PlainMessage<PositionOpen> | undefined, b: PositionOpen | PlainMessage<PositionOpen> | undefined): boolean {
    return proto3.util.equals(PositionOpen, a, b);
  }
}

/**
 * A transaction action that closes a position.
 *
 * This action's contribution to the transaction's value balance is to consume
 * an opened position NFT and contribute a closed position NFT.
 *
 * Closing a position does not immediately withdraw funds, because Penumbra
 * transactions (like any ZK transaction model) are early-binding: the prover
 * must know the state transition they prove knowledge of, and they cannot know
 * the final reserves with certainty until after the position has been deactivated.
 *
 * @generated from message penumbra.dex.PositionClose
 */
export class PositionClose extends Message<PositionClose> {
  /**
   * @generated from field: penumbra.dex.PositionId position_id = 1;
   */
  positionId?: PositionId;

  constructor(data?: PartialMessage<PositionClose>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "penumbra.dex.PositionClose";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "position_id", kind: "message", T: PositionId },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PositionClose {
    return new PositionClose().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PositionClose {
    return new PositionClose().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PositionClose {
    return new PositionClose().fromJsonString(jsonString, options);
  }

  static equals(a: PositionClose | PlainMessage<PositionClose> | undefined, b: PositionClose | PlainMessage<PositionClose> | undefined): boolean {
    return proto3.util.equals(PositionClose, a, b);
  }
}

/**
 * A transaction action that withdraws funds from a closed position.
 *
 * This action's contribution to the transaction's value balance is to consume a
 * closed position NFT and contribute a withdrawn position NFT, as well as all
 * of the funds that were in the position at the time of closing.
 *
 * @generated from message penumbra.dex.PositionWithdraw
 */
export class PositionWithdraw extends Message<PositionWithdraw> {
  /**
   * @generated from field: penumbra.dex.PositionId position_id = 1;
   */
  positionId?: PositionId;

  /**
   * A transparent (zero blinding factor) commitment to the position's final reserves and fees.
   *
   * The chain will check this commitment by recomputing it with the on-chain state.
   *
   * @generated from field: penumbra.crypto.ValueCommitment reserves_commitment = 2;
   */
  reservesCommitment?: ValueCommitment;

  constructor(data?: PartialMessage<PositionWithdraw>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "penumbra.dex.PositionWithdraw";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "position_id", kind: "message", T: PositionId },
    { no: 2, name: "reserves_commitment", kind: "message", T: ValueCommitment },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PositionWithdraw {
    return new PositionWithdraw().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PositionWithdraw {
    return new PositionWithdraw().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PositionWithdraw {
    return new PositionWithdraw().fromJsonString(jsonString, options);
  }

  static equals(a: PositionWithdraw | PlainMessage<PositionWithdraw> | undefined, b: PositionWithdraw | PlainMessage<PositionWithdraw> | undefined): boolean {
    return proto3.util.equals(PositionWithdraw, a, b);
  }
}

/**
 * A transaction action that claims retroactive rewards for a historical
 * position.
 *
 * This action's contribution to the transaction's value balance is to consume a
 * withdrawn position NFT and contribute its reward balance.
 *
 * @generated from message penumbra.dex.PositionRewardClaim
 */
export class PositionRewardClaim extends Message<PositionRewardClaim> {
  /**
   * @generated from field: penumbra.dex.PositionId position_id = 1;
   */
  positionId?: PositionId;

  /**
   * A transparent (zero blinding factor) commitment to the position's accumulated rewards.
   *
   * The chain will check this commitment by recomputing it with the on-chain state.
   *
   * @generated from field: penumbra.crypto.ValueCommitment rewards_commitment = 2;
   */
  rewardsCommitment?: ValueCommitment;

  constructor(data?: PartialMessage<PositionRewardClaim>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "penumbra.dex.PositionRewardClaim";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "position_id", kind: "message", T: PositionId },
    { no: 2, name: "rewards_commitment", kind: "message", T: ValueCommitment },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PositionRewardClaim {
    return new PositionRewardClaim().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PositionRewardClaim {
    return new PositionRewardClaim().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PositionRewardClaim {
    return new PositionRewardClaim().fromJsonString(jsonString, options);
  }

  static equals(a: PositionRewardClaim | PlainMessage<PositionRewardClaim> | undefined, b: PositionRewardClaim | PlainMessage<PositionRewardClaim> | undefined): boolean {
    return proto3.util.equals(PositionRewardClaim, a, b);
  }
}

